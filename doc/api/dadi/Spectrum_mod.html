<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dadi.Spectrum_mod API documentation</title>
<meta name="description" content="Contains Spectrum object, which represents frequency spectra." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dadi.Spectrum_mod</code></h1>
</header>
<section id="section-intro">
<p>Contains Spectrum object, which represents frequency spectra.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains Spectrum object, which represents frequency spectra.
&#34;&#34;&#34;
import logging
logging.basicConfig()
logger = logging.getLogger(&#39;Spectrum_mod&#39;)

import gzip, operator, os, sys

import numpy
from numpy import newaxis as nuax
import numpy as np
# Account for difference in scipy installations.
from scipy.special import comb
from scipy.integrate import trapz
from scipy.special import betainc

import dadi.Numerics
from dadi.Numerics import reverse_array, _cached_projection, _lncomb, BetaBinomConvolution

_dbeta_cache = {}
def cached_dbeta(nx, xx):
    key = nx, tuple(xx)

    xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)
    if key not in _dbeta_cache:
        dbeta1 = np.empty((nx+1,len(xx)-1))
        dbeta2 = np.empty((nx+1,len(xx)-1))
        for ii in range(0, nx+1):
            b = betainc(ii+1,nx-ii+1,xx)
            dbeta1[ii] = b[1:]-b[:-1]
            b = betainc(ii+2,nx-ii+1,xx)
            dbeta2[ii] = b[1:]-b[:-1]
        _dbeta_cache[key] = dbeta1, dbeta2
    dbeta1, dbeta2 = _dbeta_cache[key]
    return dbeta1, dbeta2

class Spectrum(numpy.ma.masked_array):
    &#34;&#34;&#34;
    Represents a frequency spectrum.

    Spectra are represented by masked arrays. The masking allows us to ignore
    specific entries in the spectrum. Most often, these are the absent and fixed
    categories.

    The constructor has the format:
        fs = dadi.Spectrum(data, mask, mask_corners, data_folded, check_folding,
                           pop_ids, extrap_x)
        
        data: The frequency spectrum data
        mask: An optional array of the same size as data. &#39;True&#39; entires in
              this array are masked in the Spectrum. These represent missing
              data categories. (For example, you may not trust your singleton
              SNP calling.)
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked. Typically these
                      entries are unobservable, and dadi cannot reliably
                      calculate them, so you will almost always want
                      mask_corners=True.g
        data_folded: If True, it is assumed that the input data is folded. An
                     error will be raised if the input data and mask are not
                     consistent with a folded Spectrum.
        check_folding: If True and data_folded=True, the data and mask will be
                       checked to ensure they are consistent with a folded
                       Spectrum. If they are not, a warning will be printed.
        pop_ids: Optional list of strings containing the population labels.
        extrap_x: Optional floating point value specifying x value to use
                  for extrapolation.
    &#34;&#34;&#34;
    def __new__(subtype, data, mask=numpy.ma.nomask, mask_corners=True, 
                data_folded=None, check_folding=True, dtype=float, copy=True, 
                fill_value=numpy.nan, keep_mask=True, shrink=True, 
                pop_ids=None, extrap_x=None):
        data = numpy.asanyarray(data)

        if mask is numpy.ma.nomask:
            mask = numpy.ma.make_mask_none(data.shape)

        subarr = numpy.ma.masked_array(data, mask=mask, dtype=dtype, copy=copy,
                                       fill_value=fill_value, keep_mask=True, 
                                       shrink=True)
        subarr = subarr.view(subtype)

        if hasattr(data, &#39;folded&#39;):
            if data_folded is None or data_folded == data.folded:
                subarr.folded = data.folded
            elif data_folded != data.folded:
                raise ValueError(&#39;Data does not have same folding status as &#39;
                                 &#39;was called for in Spectrum constructor.&#39;)
        elif data_folded is not None:
            subarr.folded = data_folded
        else:
            subarr.folded = False

        # Check that if we&#39;re declaring that the input data is folded, it
        # actually is, and the mask reflects this.
        if data_folded:
            total_samples = numpy.sum(subarr.sample_sizes)
            total_per_entry = subarr._total_per_entry()
            # Which entries are nonsense in the folded fs.
            where_folded_out = total_per_entry &gt; int(total_samples/2)
            if check_folding\
               and not numpy.all(subarr.data[where_folded_out] == 0):
                logger.warn(&#39;Creating Spectrum with data_folded = True, but &#39;
                            &#39;data has non-zero values in entries which are &#39;
                            &#39;nonsensical for a folded Spectrum.&#39;)
            if check_folding\
               and not numpy.all(subarr.mask[where_folded_out]):
                logger.warn(&#39;Creating Spectrum with data_folded = True, but &#39;
                            &#39;mask is not True for all entries which are &#39;
                            &#39;nonsensical for a folded Spectrum.&#39;)

        if hasattr(data, &#39;pop_ids&#39;):
            if pop_ids is None or pop_ids == data.pop_ids:
                subarr.pop_ids = data.pop_ids
            elif pop_ids != data.pop_ids:
                logger.warn(&#39;Changing population labels in construction of new &#39;
                            &#39;Spectrum.&#39;)
                if len(pop_ids) != subarr.ndim:
                    raise ValueError(&#39;pop_ids must be of length equal to &#39;
                                     &#39;dimensionality of Spectrum.&#39;)
                subarr.pop_ids = pop_ids
        else:
            if pop_ids is not None and len(pop_ids) != subarr.ndim:
                raise ValueError(&#39;pop_ids must be of length equal to &#39;
                                 &#39;dimensionality of Spectrum.&#39;)
            subarr.pop_ids = pop_ids

        if mask_corners:
            subarr.mask_corners()

        subarr.extrap_x = extrap_x

        return subarr

    # See http://www.scipy.org/Subclasses for information on the
    # __array_finalize__ and __array_wrap__ methods. I had to do some debugging
    # myself to discover that I also needed _update_from.
    # Also, see http://docs.scipy.org/doc/numpy/reference/arrays.classes.html
    # Also, see http://docs.scipy.org/doc/numpy/user/basics.subclassing.html
    #
    # We need these methods to ensure extra attributes get copied along when
    # we do arithmetic on the FS.
    def __array_finalize__(self, obj):
        if obj is None: 
            return
        numpy.ma.masked_array.__array_finalize__(self, obj)
        self.folded = getattr(obj, &#39;folded&#39;, &#39;unspecified&#39;)
        self.pop_ids = getattr(obj, &#39;pop_ids&#39;, None)
        self.extrap_x = getattr(obj, &#39;extrap_x&#39;, None)
    def __array_wrap__(self, obj, context=None):
        result = obj.view(type(self))
        result = numpy.ma.masked_array.__array_wrap__(self, obj, 
                                                      context=context)
        result.folded = self.folded
        result.pop_ids = self.pop_ids
        result.extrap_x = self.extrap_x
        return result
    def _update_from(self, obj):
        numpy.ma.masked_array._update_from(self, obj)
        if hasattr(obj, &#39;folded&#39;):
            self.folded = obj.folded
        if hasattr(obj, &#39;pop_ids&#39;):
            self.pop_ids = obj.pop_ids
        if hasattr(obj, &#39;extrap_x&#39;):
            self.extrap_x = obj.extrap_x
    # masked_array has priority 15.
    __array_priority__ = 20

    def __repr__(self):
        return &#39;Spectrum(%s, folded=%s, pop_ids=%s)&#39;\
                % (str(self), str(self.folded), str(self.pop_ids))

    def mask_corners(self):
        &#34;&#34;&#34;
        Mask the &#39;seen in 0 samples&#39; and &#39;seen in all samples&#39; entries.
        &#34;&#34;&#34;
        self.mask.flat[0] = self.mask.flat[-1] = True

    def unmask_all(self):
        &#34;&#34;&#34;
        Unmask all values.
        &#34;&#34;&#34;
        self.mask[[slice(None)]*self.Npop] = False

    def _get_sample_sizes(self):
        return numpy.asarray(self.shape) - 1
    sample_sizes = property(_get_sample_sizes)

    def _get_Npop(self):
        return self.ndim
    Npop = property(_get_Npop)

    def _ensure_dimension(self, Npop):
        &#34;&#34;&#34;
        Ensure that fs has Npop dimensions.
        &#34;&#34;&#34;
        if not self.Npop == Npop:
            raise ValueError(&#39;Only compatible with %id spectra.&#39; % Npop)

    # Make from_file a static method, so we can use it without an instance.
    @staticmethod
    def from_file(fname, mask_corners=True, return_comments=False):
        &#34;&#34;&#34;
        Read frequency spectrum from file.

        fname: String with file name to read from. If it ends in .gz, gzip
               compression is assumed.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_comments: If true, the return value is (fs, comments), where
                         comments is a list of strings containing the comments
                         from the file (without #&#39;s).

        See to_file method for details on the file format.
        &#34;&#34;&#34;
        if fname.endswith(&#39;.gz&#39;):
            fid = gzip.open(fname, &#39;rb&#39;)
        else:
            fid = open(fname, &#39;r&#39;)

        line = fid.readline()
        # Strip out the comments
        comments = []
        while line.startswith(&#39;#&#39;):
            comments.append(line[1:].strip())
            line = fid.readline()

        # Read the shape of the data
        shape_spl = line.split()
        if &#39;folded&#39; not in shape_spl and &#39;unfolded&#39; not in shape_spl:
            # This case handles the old file format
            shape = tuple([int(d) for d in shape_spl])
            folded = False
            pop_ids = None
        else:
            # This case handles the new file format
            shape,next_ii = [int(shape_spl[0])], 1
            while shape_spl[next_ii] not in [&#39;folded&#39;, &#39;unfolded&#39;]:
                shape.append(int(shape_spl[next_ii]))
                next_ii += 1
            folded = (shape_spl[next_ii] == &#39;folded&#39;)
            # Are there population labels in the file?
            if len(shape_spl) &gt; next_ii + 1:
                pop_ids = line.split(&#39;&#34;&#39;)[1::2]
            else:
                pop_ids = None

        data = numpy.fromstring(fid.readline().strip(), 
                                count=numpy.product(shape), sep=&#39; &#39;)
        # fromfile returns a 1-d array. Reshape it to the proper form.
        data = data.reshape(*shape)

        maskline = fid.readline().strip()
        if not maskline:
            # The old file format didn&#39;t have a line for the mask
            mask = None
        else:
            # This case handles the new file format
            mask = numpy.fromstring(maskline, 
                                    count=numpy.product(shape), sep=&#39; &#39;)
            mask = mask.reshape(*shape)

        fs = Spectrum(data, mask, mask_corners, data_folded=folded,
                      pop_ids=pop_ids)

        fid.close()
        if not return_comments:
            return fs
        else:
            return fs,comments

    fromfile = from_file

    def to_file(self, fname, precision=16, comment_lines = [], 
                foldmaskinfo=True):
        &#34;&#34;&#34;
        Write frequency spectrum to file.

        fname: File name to write to.  If string ends in .gz, file will be saved
               with gzip compression.
        precision: precision with which to write out entries of the SFS. (They
                   are formated via %.&lt;p&gt;g, where &lt;p&gt; is the precision.)
        comment lines: list of strings to be used as comment lines in the header
                       of the output file.
        foldmaskinfo: If False, folding and mask and population label
                      information will not be saved. This conforms to the file
                      format for dadi versions prior to 1.3.0.

        The file format is:
            # Any number of comment lines beginning with a &#39;#&#39;
            A single line containing N integers giving the dimensions of the fs
              array. So this line would be &#39;5 5 3&#39; for an SFS that was 5x5x3.
              (That would be 4x4x2 *samples*.)
            On the *same line*, the string &#39;folded&#39; or &#39;unfolded&#39; denoting the
              folding status of the array
            On the *same line*, optional strings each containing the population
              labels in quotes separated by spaces, e.g. &#34;pop 1&#34; &#34;pop 2&#34;
            A single line giving the array elements. The order of elements is 
              e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] ... fs[0,1,0] fs[0,1,1] ...
            A single line giving the elements of the mask in the same order as
              the data line. &#39;1&#39; indicates masked, &#39;0&#39; indicates unmasked.
        &#34;&#34;&#34;
        # Open the file object.
        if fname.endswith(&#39;.gz&#39;):
            fid = gzip.open(fname, &#39;wb&#39;)
        else:
            fid = open(fname, &#39;w&#39;)

        # Write comments
        for line in comment_lines:
            fid.write(&#39;# &#39;)
            fid.write(line.strip())
            fid.write(&#39;\n&#39;)

        # Write out the shape of the fs
        for elem in self.data.shape:
            fid.write(&#39;%i &#39; % elem)

        if foldmaskinfo:
            if not self.folded:
                fid.write(&#39;unfolded&#39;)
            else:
                fid.write(&#39;folded&#39;)
            if self.pop_ids is not None:
                for label in self.pop_ids:
                    fid.write(&#39; &#34;%s&#34;&#39; % label)

        fid.write(&#39;\n&#39;)

        # Write the data to the file. The obnoxious ravel call is to
        # ensure compatibility with old version that used self.data.tofile.
        numpy.savetxt(fid, [self.data.ravel()], delimiter=&#39; &#39;,
                      fmt=&#39;%%.%ig&#39; % precision)

        if foldmaskinfo:
            # Write the mask to the file
            numpy.savetxt(fid, [numpy.asarray(self.mask, int).ravel()],
                          delimiter=&#39; &#39;, fmt=&#39;%d&#39;)

        fid.close()

    tofile = to_file

    ## Overide the (perhaps confusing) original numpy tofile method.
    #def tofile(self, *args,**kwargs):
    #    self.to_file(*args, **kwargs)

    def project(self, ns):
        &#34;&#34;&#34;
        Project to smaller sample size.

        ns: Sample sizes for new spectrum.
        &#34;&#34;&#34;
        if len(ns) != self.Npop:
            raise ValueError(&#39;Requested sample sizes not of same dimension &#39;
                             &#39;as spectrum. Perhaps you need to marginalize &#39;
                             &#39;over some populations first?&#39;)
        if numpy.any(numpy.asarray(ns) &gt; numpy.asarray(self.sample_sizes)):
            raise ValueError(&#39;Cannot project to a sample size greater than &#39;
                             &#39;original. Original size is %s and requested size &#39;
                             &#39;is %s.&#39; % (self.sample_sizes, ns))

        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # projecting.
        if original_folded:
            output = self.unfold()
        else:
            output = self.copy()

        # Iterate over each axis, applying the projection.
        for axis,proj in enumerate(ns):
            if proj != self.sample_sizes[axis]:
                output = output._project_one_axis(proj, axis)

        output.pop_ids = self.pop_ids
        output.extrap_x = self.extrap_x

        # Return folded or unfolded as original.
        if original_folded:
            return output.fold()
        else:
            return output

    def _project_one_axis(self, n, axis=0):
        &#34;&#34;&#34;
        Project along a single axis.
        &#34;&#34;&#34;
        # This gets a little tricky with fancy indexing to make it work
        # for fs with arbitrary number of dimensions.
        if n &gt; self.sample_sizes[axis]:
            raise ValueError(&#39;Cannot project to a sample size greater than &#39;
                             &#39;original. Called sizes were from %s to %s.&#39; 
                             % (self.sample_sizes[axis], n))

        newshape = list(self.shape)
        newshape[axis] = n+1
        # Create a new empty fs that we&#39;ll fill in below.
        pfs = Spectrum(numpy.zeros(newshape), mask_corners=False)

        # Set up for our fancy indexes. These slices are currently like
        # [:,:,...]
        from_slice = [slice(None) for ii in range(self.Npop)]
        to_slice = [slice(None) for ii in range(self.Npop)]
        proj_slice = [nuax for ii in range(self.Npop)]

        proj_from = self.sample_sizes[axis]
        # For each possible number of hits.
        for hits in range(proj_from+1):
            # Adjust the slice in the array we&#39;re projecting from.
            from_slice[axis] = slice(hits, hits+1)
            # These are the least and most possible hits we could have in the
            #  projected fs.
            least, most = max(n - (proj_from - hits), 0), min(hits,n)
            to_slice[axis] = slice(least, most+1)
            # The projection weights.
            proj = _cached_projection(n, proj_from, hits)
            proj_slice[axis] = slice(least, most+1)
            # Do the multiplications
            pfs.data[tuple(to_slice)] += self.data[tuple(from_slice)] * proj[tuple(proj_slice)]
            pfs.mask[tuple(to_slice)] = numpy.logical_or(pfs.mask[tuple(to_slice)],
                                                         self.mask[tuple(from_slice)])

        return pfs

    def marginalize(self, over, mask_corners=True):
        &#34;&#34;&#34;
        Reduced dimensionality spectrum summing over some populations.

        over: sequence of axes to sum over. For example (0,2) will sum over
              populations 0 and 2.
        mask_corners: If True, the typical corners of the resulting fs will be
                      masked
        &#34;&#34;&#34;
        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # marginalizing.
        if original_folded:
            output = self.unfold()
        else:
            output = self.copy()

        orig_mask = output.mask.copy()
        orig_mask.flat[0] = orig_mask.flat[-1] = False
        if numpy.any(orig_mask):
            logger.warn(&#39;Marginalizing a Spectrum with internal masked values. &#39;
                        &#39;This may not be a well-defined operation.&#39;)

        # Do the marginalization
        for axis in sorted(over)[::-1]:
            output = output.sum(axis=axis)
        pop_ids = None
        if self.pop_ids is not None:
            pop_ids = list(self.pop_ids)
            for axis in sorted(over)[::-1]:
                del pop_ids[axis]
        output.folded = False
        output.pop_ids = pop_ids
        output.extrap_x = self.extrap_x

        if mask_corners:
            output.mask_corners()

        # Return folded or unfolded as original.
        if original_folded:
            return output.fold()
        else:
            return output

    def filter_pops(self, tokeep, mask_corners=True):
        &#34;&#34;&#34;
        Filter Spectrum to keep only certain populations.

        Returns new Spectrum with len(tokeep) populations.
        Note: This is similar in practice to the marginalize operation. But here
              populations are numbered from 1, as in the majority of dadi.

        tokeep: List of population numbers to keep, numbering from 1.
        mask_corners: If True, the typical corners of the resulting fs will be
                      masked
        &#34;&#34;&#34;
        toremove = list(range(0, self.ndim))
        for pop_ii in tokeep:
            # Apply -1 factor to account for indexing in marginalize
            toremove.remove(pop_ii-1)
        return self.marginalize(toremove)

    def _counts_per_entry(self):
        &#34;&#34;&#34;
        Counts per population for each entry in the fs.
        &#34;&#34;&#34;
        ind = numpy.indices(self.shape)
        # Transpose the first access to the last, so ind[ii,jj,kk] = [ii,jj,kk]
        ind = ind.transpose(list(range(1,self.Npop+1))+[0])
        return ind

    def _total_per_entry(self):
        &#34;&#34;&#34;
        Total derived alleles for each entry in the fs.
        &#34;&#34;&#34;
        return numpy.sum(self._counts_per_entry(), axis=-1)

    def log(self):
        &#34;&#34;&#34;
        Return the natural logarithm of the entries of the frequency spectrum.

        Only necessary because numpy.ma.log now fails to propagate extra
        attributes after numpy 1.10.
        &#34;&#34;&#34;
        logfs = numpy.ma.log(self)
        logfs.folded = self.folded
        logfs.pop_ids = self.pop_ids
        logfs.extrap_x = self.extrap_x
        return logfs

    def fold(self):
        &#34;&#34;&#34;
        Folded frequency spectrum
    
        The folded fs assumes that information on which allele is ancestral or
        derived is unavailable. Thus the fs is in terms of minor allele 
        frequency.  Note that this makes the fs into a &#34;triangular&#34; array.
    
        Note that if a masked cell is folded into non-masked cell, the
        destination cell is masked as well.

        Note also that folding is not done in-place. The return value is a new
        Spectrum object.
        &#34;&#34;&#34;
        if self.folded:
            raise ValueError(&#39;Input Spectrum is already folded.&#39;)

        # How many samples total do we have? The folded fs can only contain
        # entries up to total_samples/2 (rounded down).
        total_samples = numpy.sum(self.sample_sizes)

        total_per_entry = self._total_per_entry()
    
        # Here&#39;s where we calculate which entries are nonsense in the folded fs.
        where_folded_out = total_per_entry &gt; int(total_samples/2)
    
        original_mask = self.mask
        # Here we create a mask that masks any values that were masked in
        # the original fs (or folded onto by a masked value).
        final_mask = numpy.logical_or(original_mask, 
                                      reverse_array(original_mask))
        
        # To do the actual folding, we take those entries that would be folded
        # out, reverse the array along all axes, and add them back to the
        # original fs.
        reversed = reverse_array(numpy.where(where_folded_out, self, 0))
        folded = numpy.ma.masked_array(self.data + reversed)
        folded.data[where_folded_out] = 0
    
        # Deal with those entries where assignment of the minor allele is
        # ambiguous.
        where_ambiguous = (total_per_entry == total_samples/2.)
        ambiguous = numpy.where(where_ambiguous, self, 0)
        folded += -0.5*ambiguous + 0.5*reverse_array(ambiguous)
    
        # Mask out the remains of the folding operation.
        final_mask = numpy.logical_or(final_mask, where_folded_out)

        outfs = Spectrum(folded, mask=final_mask, data_folded=True,
                         pop_ids=self.pop_ids)
        outfs.extrap_x = self.extrap_x
        return outfs

    def unfold(self):
        &#34;&#34;&#34;
        Unfolded frequency spectrum
    
        It is assumed that each state of a SNP is equally likely to be
        ancestral.

        Note also that unfolding is not done in-place. The return value is a new
        Spectrum object.
        &#34;&#34;&#34;
        if not self.folded:
            raise ValueError(&#39;Input Spectrum is not folded.&#39;)

        # Unfolding the data is easy.
        reversed_data = reverse_array(self.data)
        newdata = (self.data + reversed_data)/2.

        # Unfolding the mask is trickier. We want to preserve masking of entries
        # that were masked in the original Spectrum.
        # Which entries in the original Spectrum were masked solely because
        # they are incompatible with a folded Spectrum?
        total_samples = numpy.sum(self.sample_sizes)
        total_per_entry = self._total_per_entry()
        where_folded_out = total_per_entry &gt; int(total_samples/2)

        newmask = numpy.logical_xor(self.mask, where_folded_out)
        newmask = numpy.logical_or(newmask, reverse_array(newmask))
    
        outfs = Spectrum(newdata, mask=newmask, data_folded=False, 
                         pop_ids=self.pop_ids)
        outfs.extrap_x = self.extrap_x
        return outfs

    def fixed_size_sample(self, nsamples, only_nonmasked=False):
        &#34;&#34;&#34;
        Generate a resampled fs from the current one.

        nsamples: Number of samples to include in the new FS.
        only_nonmasked: If True, only SNPs from non-masked will be resampled. 
                        Otherwise, all SNPs will be used.
        &#34;&#34;&#34;
        flat = self.flatten()
        if only_nonmasked:
            pvals = flat.data/flat.sum()
            pvals[flat.mask] = 0
        else:
            pvals = flat.data/flat.data.sum()
    
        sample = numpy.random.multinomial(int(nsamples), pvals)
        sample = sample.reshape(self.shape)
    
        return dadi.Spectrum(sample, mask=self.mask, pop_ids=self.pop_ids)

    def sample(self):
        &#34;&#34;&#34;
        Generate a Poisson-sampled fs from the current one.

        Note: Entries where the current fs is masked will be masked in the
              output sampled fs.
        &#34;&#34;&#34;
        import scipy.stats
        # These are entries where the sampling has no meaning, b/c fs is masked.
        bad_entries = self.mask
        # We convert to a 1-d array for passing into the sampler
        means = self.ravel().copy()
        # Filter out those bad entries.
        means[bad_entries.ravel()] = 1
        # Sample
        samp = scipy.stats.distributions.poisson.rvs(means, size=len(means))
        # Replace bad entries with zero
        samp[bad_entries.ravel()] = 0
        # Convert back to a properly shaped array
        samp = samp.reshape(self.shape)
        # Convert to a fs and mask the bad entries
        samp = Spectrum(samp, mask=self.mask, data_folded=self.folded,
                        pop_ids = self.pop_ids)
        return samp

    @staticmethod
    def from_ms_file(fid, average=True, mask_corners=True, return_header=False,
                     pop_assignments=None, pop_ids=None, bootstrap_segments=1):
        &#34;&#34;&#34;
        Read frequency spectrum from file of ms output.

        fid: string with file name to read from or an open file object.
        average: If True, the returned fs is the average over the runs in the ms
                 file. If False, the returned fs is the sum.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_header: If True, the return value is (fs, (command,seeds), where
                       command and seeds are strings containing the ms
                       commandline and the seeds used.
        pop_assignments: If None, the assignments of samples to populations is
                         done automatically, using the assignment in the ms
                         command line. To manually assign populations, pass a
                         list of the from [6,8]. This example places
                         the first 6 samples into population 1, and the next 8
                         into population 2.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        bootstrap_segments: If bootstrap_segments is an integer greater than 1,
                            the data will be broken up into that many segments
                            based on SNP position. Instead of single FS, a list
                            of spectra will be returned, one for each segment.
        &#34;&#34;&#34;
        newfile = False
        # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
        # use to open a file.
        if not hasattr(fid, &#39;read&#39;):
            newfile = True
            fid = open(fid, &#39;r&#39;)

        # Parse the commandline
        command = line = fid.readline()
        command_terms = line.split()
        
        if command_terms[0].count(&#39;ms&#39;):
            runs = int(command_terms[2])
            try:
                pop_flag = command_terms.index(&#39;-I&#39;)
                num_pops = int(command_terms[pop_flag+1])
                pop_samples = [int(command_terms[pop_flag+ii])
                               for ii in range(2, 2+num_pops)]
            except ValueError:
                num_pops = 1
                pop_samples = [int(command_terms[1])]
        else:
            raise ValueError(&#39;Unrecognized command string: %s.&#39; % command)
        
        total_samples = numpy.sum(pop_samples)
        if pop_assignments:
            num_pops = len(pop_assignments)
            pop_samples = pop_assignments

        sample_indices = numpy.cumsum([0] + pop_samples)
        bottom_l = sample_indices[:-1]
        top_l = sample_indices[1:]
        
        seeds = line = fid.readline()
        while not line.startswith(&#39;//&#39;):
            line = fid.readline()
        
        counts = numpy.zeros(len(pop_samples), numpy.int_)
        fs_shape = numpy.asarray(pop_samples) + 1
        dimension = len(counts)
        
        if dimension &gt; 1:
            bottom0 = bottom_l[0]
            top0 = top_l[0]
            bottom1 = bottom_l[1]
            top1 = top_l[1]
        if dimension &gt; 2:
            bottom2 = bottom_l[2]
            top2 = top_l[2]
        if dimension &gt; 3:
            bottom3 = bottom_l[3]
            top3 = top_l[3]
        if dimension &gt; 4:
            bottom4 = bottom_l[4]
            top4 = top_l[4]
        if dimension &gt; 5:
            bottom5 = bottom_l[5]
            top5 = top_l[5]
        
        all_data = [numpy.zeros(fs_shape, numpy.int_)
                    for boot_ii in range(bootstrap_segments)]
        for run_ii in range(runs):
            line = fid.readline()
            segsites = int(line.split()[-1])
            
            if segsites == 0:
                # Special case, need to read 3 lines to stay synced.
                for _ in range(3):
                    line = fid.readline()
                continue
            line = fid.readline()
            while not line.startswith(&#39;positions&#39;):
                line = fid.readline()

            # Read SNP positions for creating bootstrap segments
            positions = [float(_) for _ in line.split()[1:]]
            # Where we should break our interval to create our bootstraps
            breakpts = numpy.linspace(0, 1, bootstrap_segments+1)
            # The indices that correspond to those breakpoints
            break_iis = numpy.searchsorted(positions, breakpts)
            # Correct for searchsorted behavior if last position is 1,
            # to ensure all SNPs are captured
            break_iis[-1] = len(positions)
        
            # Read the chromosomes in
            chromos = fid.read((segsites+1)*total_samples)
        
            # For each bootstrap segment, relevant SNPs run from start_ii:end_ii
            for boot_ii, (start_ii, end_ii) \
                    in enumerate(zip(break_iis[:-1], break_iis[1:])):
                # Use the data array corresponding to this bootstrap segment
                data = all_data[boot_ii]
                for snp in range(start_ii, end_ii):
                    # Slice to get all the entries that refer to a given SNP
                    this_snp = chromos[snp::segsites+1]
                    # Count SNPs per population, and record them.
                    if dimension == 1:
                        data[this_snp.count(&#39;1&#39;)] += 1
                    elif dimension == 2:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;)] += 1
                    elif dimension == 3:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;)] += 1
                    elif dimension == 4:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;)] += 1
                    elif dimension == 5:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;),
                             this_snp[bottom4:top4].count(&#39;1&#39;)] += 1
                    elif dimension == 6:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;),
                             this_snp[bottom4:top4].count(&#39;1&#39;),
                             this_snp[bottom5:top5].count(&#39;1&#39;)] += 1
                    else:
                        # This is noticably slower, so we special case the cases
                        # above.
                        for dim_ii in range(dimension):
                            bottom = bottom_l[dim_ii]
                            top = top_l[dim_ii]
                            counts[dim_ii] = this_snp[bottom:top].count(&#39;1&#39;)
                        data[tuple(counts)] += 1
        
            # Read to the next iteration
            line = fid.readline()
            line = fid.readline()

        if newfile:
            fid.close()

        all_fs = [Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
                  for data in all_data]
        if average:
            all_fs = [fs/runs for fs in all_fs]

        # If we aren&#39;t setting up for bootstrapping, return fs, rather than a
        # list of length 1. (This ensures backward compatibility.)
        if bootstrap_segments == 1:
            all_fs = all_fs[0]

        if not return_header:
            return all_fs
        else:
            return all_fs, (command,seeds)

    @staticmethod
    def from_sfscode_file(fid, sites=&#39;all&#39;, average=True, mask_corners=True, 
                          return_header=False, pop_ids=None):
        &#34;&#34;&#34;
        Read frequency spectrum from file of sfs_code output.

        fid: string with file name to read from or an open file object.
        sites: If sites==&#39;all&#39;, return the fs of all sites. If sites == &#39;syn&#39;,
               use only synonymous mutations. If sites == &#39;nonsyn&#39;, use
               only non-synonymous mutations.
        average: If True, the returned fs is the average over the runs in the 
                 file. If False, the returned fs is the sum.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_header: If true, the return value is (fs, (command,seeds), where
                       command and seeds are strings containing the ms
                       commandline and the seeds used.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        &#34;&#34;&#34;
        newfile = False
        # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
        # use to open a file.
        if not hasattr(fid, &#39;read&#39;):
            newfile = True
            fid = open(fid, &#39;r&#39;)

        if sites == &#39;all&#39;:
            only_nonsyn, only_syn = False, False
        elif sites == &#39;syn&#39;:
            only_nonsyn, only_syn = False, True
        elif sites == &#39;nonsyn&#39;:
            only_nonsyn, only_syn = True, False
        else:
            raise ValueError(&#34;&#39;sites&#39; argument must be one of (&#39;all&#39;, &#39;syn&#39;, &#34;
                             &#34;&#39;nonsyn&#39;).&#34;)
        
        command = fid.readline()
        command_terms = command.split()
        
        runs = int(command_terms[2])
        num_pops = int(command_terms[1])
        
        # sfs_code default is 6 individuals, and I assume diploid pop
        pop_samples = [12] *  num_pops
        if &#39;--sampSize&#39; in command_terms or &#39;-n&#39; in command_terms:
            try:
                pop_flag = command_terms.index(&#39;--sampSize&#39;)
                pop_flag = command_terms.index(&#39;-n&#39;)
            except ValueError:
                pass
            pop_samples = [2*int(command_terms[pop_flag+ii])
                           for ii in range(1, 1+num_pops)]
        
        pop_samples = numpy.asarray(pop_samples)
        pop_fixed_str = [&#39;,%s.-1&#39; % i for i in range(num_pops)]
        pop_count_str = [&#39;,%s.&#39; % i for i in range(num_pops)]
        
        seeds = fid.readline()
        line = fid.readline()
        
        data = numpy.zeros(numpy.asarray(pop_samples)+1, numpy.int_)
        
        # line = //iteration...
        line = fid.readline()
        for iter_ii in range(runs):
            for ii in range(5):
                line = fid.readline()
        
            # It is possible for a mutation to be listed several times in the
            # output.  To accomodate this, I keep a dictionary of identities
            # for those mutations, and hold off processing them until I&#39;ve seen
            # all mutations listed for the iteration.
            mut_dict = {}
            
            # Loop until this iteration ends.
            while not line.startswith(&#39;//&#39;) and line != &#39;&#39;:
                split_line = line.split(&#39;;&#39;)
                if split_line[-1] == &#39;\n&#39;:
                    split_line = split_line[:-1]
        
                # Loop over mutations on this line.
                for mut_ii, mutation in enumerate(split_line):
                    counts_this_mut = numpy.zeros(num_pops, numpy.int_)
        
                    split_mut = mutation.split(&#39;,&#39;)
        
                    # Exclude synonymous mutations
                    if only_nonsyn and split_mut[7] == &#39;0&#39;:
                        continue
                    # Exclude nonsynonymous mutations
                    if only_syn and split_mut[7] == &#39;1&#39;:
                        continue
        
                    ind_start = len(&#39;,&#39;.join(split_mut[:12]))
                    by_individual = mutation[ind_start:]
        
                    mut_id = &#39;,&#39;.join(split_mut[:4] + split_mut[5:11])
        
                    # Count mutations in each population
                    for pop_ii,fixed_str,count_str\
                            in zip(range(num_pops), pop_fixed_str, 
                                   pop_count_str):
                        if fixed_str in by_individual:
                            counts_this_mut[pop_ii] = pop_samples[pop_ii]
                        else:
                            counts_this_mut[pop_ii] =\
                                    by_individual.count(count_str)
        
                    # Initialize the list that will track the counts for this
                    # mutation. Using setdefault means that it won&#39;t overwrite
                    # if there&#39;s already a list stored there.
                    mut_dict.setdefault(mut_id, [0]*num_pops)
                    for ii in range(num_pops):
                        if counts_this_mut[ii] &gt; 0 and mut_dict[mut_id][ii] &gt; 0:
                            sys.stderr.write(&#39;Contradicting counts between &#39;
                                             &#39;listings for mutation %s in &#39;
                                             &#39;population %i.&#39; 
                                             % (mut_id, ii))
                        mut_dict[mut_id][ii] = max(counts_this_mut[ii], 
                                                   mut_dict[mut_id][ii])
        
                line = fid.readline()
        
            # Now apply all the mutations with fixations that we deffered.
            for mut_id, counts in mut_dict.items():
                if numpy.any(numpy.asarray(counts) &gt; pop_samples):
                    sys.stderr.write(&#39;counts_this_mut &gt; pop_samples: %s &gt; &#39;
                                     &#39;%s\n%s\n&#39; % (counts, pop_samples, mut_id))
                    counts = numpy.minimum(counts, pop_samples)
                data[tuple(counts)] += 1
        
        if newfile:
            fid.close()
        
        fs = Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
        if average:
            fs /= runs

        if not return_header:
            return fs
        else:
            return fs, (command,seeds)

    def Fst(self):
        &#34;&#34;&#34;
        Wright&#39;s Fst between the populations represented in the fs.
    
        This estimate of Fst assumes random mating, because we don&#39;t have
        heterozygote frequencies in the fs.
    
        Calculation is by the method of Weir and Cockerham _Evolution_ 38:1358
        (1984).  For a single SNP, the relevant formula is at the top of page
        1363. To combine results between SNPs, we use the weighted average
        indicated by equation 10.
        &#34;&#34;&#34;
        # This gets a little obscure because we want to be able to work with
        # spectra of arbitrary dimension.
    
        # First quantities from page 1360
        r = self.Npop
        ns = self.sample_sizes
        nbar = numpy.mean(ns)
        nsum = numpy.sum(ns)
        nc = (nsum - numpy.sum(ns**2)/nsum)/(r-1)
    
        # counts_per_pop is an r+1 dimensional array, where the last axis simply
        # records the indices of the entry. 
        # For example, counts_per_pop[4,19,8] = [4,19,8]
        counts_per_pop = numpy.indices(self.shape)
        counts_per_pop = numpy.transpose(counts_per_pop, axes=list(range(1,r+1))+[0])
    
        # The last axis of ptwiddle is now the relative frequency of SNPs in
        # that bin in each of the populations.
        ptwiddle = 1.*counts_per_pop/ns
    
        # Note that pbar is of the same shape as fs...
        pbar = numpy.sum(ns*ptwiddle, axis=-1)/nsum
    
        # We need to use &#39;this_slice&#39; to get the proper aligment between
        # ptwiddle and pbar.
        this_slice = [slice(None)]*r + [numpy.newaxis]
        s2 = numpy.sum(ns * (ptwiddle - pbar[tuple(this_slice)])**2, axis=-1)/((r-1)*nbar)
    
        # Note that this &#39;a&#39; differs from equation 2, because we&#39;ve used
        # equation 3 and b = 0 to solve for hbar.
        a = nbar/nc * (s2 - 1/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2))
        d = 2*nbar/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2)
    
        # The weighted sum over loci.
        asum = (self * a).sum()
        dsum = (self * d).sum()
    
        return asum/(asum+dsum)

    def S(self):
        &#34;&#34;&#34;
        Segregating sites.
        &#34;&#34;&#34;
        oldmask = self.mask.copy()
        self.mask_corners()
        S = self.sum()
        self.mask = oldmask
        return S
    
    def Watterson_theta(self):
        &#34;&#34;&#34;
        Watterson&#39;s estimator of theta.
    
        Note that is only sensible for 1-dimensional spectra.
        &#34;&#34;&#34;
        if self.Npop != 1:
            raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)
    
        n = self.sample_sizes[0]
        S = self.S()
        an = numpy.sum(1./numpy.arange(1,n))
    
        return S/an
    
    def theta_L(self):
        &#34;&#34;&#34;
        theta_L as defined by Zeng et al. &#34;Statistical Tests for Detecting
        Positive Selection by Utilizing High-Frequency Variants&#34; (2006)
        Genetics
    
        Note that is only sensible for 1-dimensional spectra.
        &#34;&#34;&#34;
        if self.Npop != 1:
            raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)
    
        n = self.sample_sizes[0]
        return numpy.sum(numpy.arange(1,n)*self[1:n])/(n-1)

    def Zengs_E(self):
        &#34;&#34;&#34;
        Zeng et al.&#39;s E statistic.

        From Zeng et al. &#34;Statistical Tests for Detecting Positive Selection by
        Utilizing High-Frequency Variants&#34; (2006) Genetics
        &#34;&#34;&#34;
        num = self.theta_L() - self.Watterson_theta()

        n = self.sample_sizes[0]

        # See after Eq. 3
        an = numpy.sum(1./numpy.arange(1,n))
        # See after Eq. 9
        bn = numpy.sum(1./numpy.arange(1,n)**2)
        s = self.S()

        # See immediately after Eq. 12
        theta = self.Watterson_theta()
        theta_sq = s*(s-1.)/(an**2 + bn)

        # Eq. 14
        var = (n/(2.*(n-1.)) - 1./an) * theta\
                + (bn/an**2 + 2.*(n/(n-1.))**2 * bn - 2*(n*bn-n+1.)/((n-1.)*an)
                   - (3.*n+1.)/(n-1.)) * theta_sq

        return num/numpy.sqrt(var)
    
    def pi(self):
        r&#34;&#34;&#34;
        Estimated expected number of pairwise differences between two
        chromosomes in the population.
    
        Note that this estimate includes a factor of sample_size/(sample_size-1)
        to make E(\hat{pi}) = theta.
        &#34;&#34;&#34;
        if self.ndim != 1:
            raise ValueError(&#34;Only defined for a one-dimensional SFS.&#34;)
    
        n = self.sample_sizes[0]
        # sample frequencies p 
        p = numpy.arange(0,n+1,dtype=float)/n
        # This expression derives from Gillespie&#39;s _Population_Genetics:_A
        # _Concise_Guide_, 2nd edition, section 2.6.
        return n/(n-1.) * 2*numpy.ma.sum(self*p*(1-p))
    
    def Tajima_D(self):
        &#34;&#34;&#34;
        Tajima&#39;s D.
    
        Following Gillespie &#34;Population Genetics: A Concise Guide&#34; pg. 45
        &#34;&#34;&#34;
        if not self.Npop == 1:
            raise ValueError(&#34;Only defined on a one-dimensional SFS.&#34;)
    
        S = self.S()
    
        n = 1.*self.sample_sizes[0]
        pihat = self.pi()
        theta = self.Watterson_theta()
    
        a1 = numpy.sum(1./numpy.arange(1,n))
        a2 = numpy.sum(1./numpy.arange(1,n)**2)
        b1 = (n+1)/(3*(n-1))
        b2 = 2*(n**2 + n + 3)/(9*n * (n-1))
        c1 = b1 - 1./a1
        c2 = b2 - (n+2)/(a1*n) + a2/a1**2
    
        C = numpy.sqrt((c1/a1)*S + c2/(a1**2 + a2) * S*(S-1))
    
        return (pihat - theta)/C

    @staticmethod
    def _from_phi_1D_direct(n, xx, phi, mask_corners=True,
                            het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros(n+1)
        for ii in range(0,n+1):
            factorx = comb(n,ii) * xx**ii * (1-xx)**(n-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            data[ii] = trapz(factorx * phi, xx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_1D_direct_inbreeding(n, xx, phi, Fx, mask_corners=True,
                                       ploidyx=2,het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        if n % ploidyx == 0:
            nInd = n/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1}.&#39;.format(str(n),str(ploidyx)))
        data = numpy.zeros(n+1)
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax  = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        for ii in range(0,n+1):
            factorx = [BetaBinomConvolution(ii,nInd,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))]
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            data[ii] = trapz(factorx*phi,xx)
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_1D_analytic(n, xx, phi, mask_corners=True, 
                              divergent=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        divergent: If True, the interval from xx[0] to xx[1] is modeled as
                   phi[1] * xx[1]/x. This captures the typical 1/x
                   divergence at x = 0.
        &#34;&#34;&#34;
        # This function uses the result that 
        # \int_0^y \Gamma(a+b)/\Gamma(a) \Gamma(b) x^{a-1) (1-x)^{b-1} 
        # is betainc(a,b,y)
        # So the integral in analytic for a piece-wise linear phi.
        data = numpy.zeros(n+1)

        # Values for xx just slighly (~1e-16) outside the range [0,1] can cause
        # betainc calculation to fail.
        xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)

        # Slopes of our linear-segments
        s = (phi[1:]-phi[:-1])/(xx[1:]-xx[:-1])
        # For the integration of the &#34;constant&#34; term in the piecewise linear
        # approximation of phi from each interval to the next.
        c1 = (phi[:-1] - s*xx[:-1])/(n+1)
        for d in range(0,n+1):
            c2 = s*(d+1)/((n+1)*(n+2))
            beta1 = betainc(d+1,n-d+1,xx)
            beta2 = betainc(d+2,n-d+1,xx)
            # Each entry is the value of the integral from one value of xx to
            # the next.
            entries = c1*(beta1[1:]-beta1[:-1]) + c2*(beta2[1:]-beta2[:-1])
            if divergent:
                entries[0] = phi[1]*xx[1]/d * betainc(d,n-d+1,xx[1])
            data[d] = numpy.sum(entries)
        fs = dadi.Spectrum(data, mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_phi_2D_direct(nx, ny, xx, yy, phi, mask_corners=True, 
                            het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        data = numpy.zeros((nx+1, ny+1))

        # Cache to avoid duplicated work.
        factorx_cache = {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx

        dx, dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            integrated_over_y = trapz(factory[numpy.newaxis,:]*phi, dx=dy)
            for ii in range(0, nx+1):
                factorx = factorx_cache[nx,ii]
                data[ii,jj] = trapz(factorx*integrated_over_y, dx=dx)

        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_2D_direct_inbreeding(nx, ny, xx, yy, phi, Fx, Fy, mask_corners=True,
                                       ploidyx=2,ploidyy=2,het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi plus
        inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        if nx % ploidyx == 0:
            nIndx = nx/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 1.&#39;.format(str(nx),str(ploidyx)))
        
        if ny % ploidyy == 0:
            nIndy = ny/ploidyy
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 2.&#39;.format(str(ny),str(ploidyy)))
        
        data = numpy.zeros((nx+1, ny+1))
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        alphay = yy*((1.0-Fy)/Fy)
        alphay[0],alphay[-1] = 1.0e-20*((1.0-Fy)/Fy), (1.0-1.0e-20)*((1.0-Fy)/Fy)
        betay = (1.0-yy)*((1.0-Fy)/Fy)
        betay[0],betay[-1] = (1.0-1.0e-20)*((1.0-Fy)/Fy), 1.0e-20*((1.0-Fy)/Fy)
        # Cache to avoid duplicated work
        factorx_cache = {}
        for ii in range(0,nx+1):
            factorx = numpy.array([BetaBinomConvolution(ii,nIndx,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))])
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        
        dx,dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = numpy.array([BetaBinomConvolution(jj,nIndy,alphay[j],betay[j],ploidy=ploidyy) for j in range(0,len(yy))])
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            integrated_over_y = trapz(factory[numpy.newaxis,:]*phi, dx=dy)
            for ii in range(0,nx+1):
                factorx = factorx_cache[nx,ii]
                data[ii,jj] = trapz(factorx*integrated_over_y, dx=dx)
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_2D_admix_props(nx, ny, xx, yy, phi, mask_corners=True, 
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        xadmix = admix_props[0][0]*xx[:,nuax] + admix_props[0][1]*yy[nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax] + admix_props[1][1]*yy[nuax,:]

        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        data = numpy.zeros((nx+1, ny+1))
        
        # Cache to avoid duplicated work.
        factorx_cache = {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx
    
        dx, dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            for ii in range(0, nx+1):
                integrated_over_y = trapz(factorx_cache[nx,ii] * factory * phi,
                                          dx=dy)
                data[ii,jj] = trapz(integrated_over_y, dx=dx)
    
        fs = Spectrum(data, mask_corners=mask_corners)
        fs.extrap_x = xx[1]
        return fs

    #@staticmethod
    #def _from_phi_2D_analytic(nx, ny, xx, yy, phi, mask_corners=True):
    #    &#34;&#34;&#34;
    #    Compute sample Spectrum from population frequency distribution phi.

    #    This function uses analytic formulae for integrating over a 
    #    piecewise-linear approximation to phi.

    #    See from_phi for explanation of arguments.
    #    &#34;&#34;&#34;
    #    data = numpy.zeros((nx+1,ny+1))

    #    xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)
    #    yy = numpy.minimum(numpy.maximum(yy, 0), 1.0)

    #    beta_cache_xx = {}
    #    for ii in range(0, nx+1):
    #        beta_cache_xx[ii+1,nx-ii+1] = betainc(ii+1,nx-ii+1,xx)
    #        beta_cache_xx[ii+2,nx-ii+1] = betainc(ii+2,nx-ii+1,xx)

    #    s_yy = (phi[:,1:]-phi[:,:-1])/(yy[nuax,1:]-yy[nuax,:-1])
    #    c1_yy = (phi[:,:-1] - s_yy*yy[nuax,:-1])/(ny+1)
    #    for jj in range(0, ny+1):
    #        c2_yy = s_yy*(jj+1)/((ny+1)*(ny+2))
    #        beta1_yy = betainc(jj+1,ny-jj+1,yy)
    #        beta2_yy = betainc(jj+2,ny-jj+1,yy)
    #        over_y = numpy.sum(c1_yy*(beta1_yy[nuax,1:]-beta1_yy[nuax,:-1])
    #                           + c2_yy*(beta2_yy[nuax,1:]-beta2_yy[nuax,:-1]),
    #                           axis=-1)

    #        s_xx = (over_y[1:]-over_y[:-1])/(xx[1:]-xx[:-1])
    #        c1_xx = (over_y[:-1] - s_xx*xx[:-1])/(nx+1)
    #        for ii in range(0, nx+1):
    #            c2_xx = s_xx*(ii+1)/((nx+1)*(nx+2))
    #            beta1_xx = beta_cache_xx[ii+1,nx-ii+1]
    #            beta2_xx = beta_cache_xx[ii+2,nx-ii+1]
    #            value = numpy.sum(c1_xx*(beta1_xx[1:]-beta1_xx[:-1])
    #                              + c2_xx*(beta2_xx[1:]-beta2_xx[:-1]))
    #            data[ii,jj] = value
    #    fs = dadi.Spectrum(data, mask_corners=mask_corners)
    #    return fs

    @staticmethod
    def _from_phi_2D_linalg(nx, ny, xx, yy, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        if not (len(xx) == len(yy) and np.allclose(xx,yy)):
            raise ValueError(&#39;Must have xx==yy to use linear algebra calculation of FS from phi.&#39;)
        dbeta1_xx, dbeta2_xx = cached_dbeta(nx, xx)
        dbeta1_yy, dbeta2_yy = cached_dbeta(ny, yy)

        # For a somewhat less terse example of this code, see the
        # (archived) _from_phi_2D_analytic function.
        s_yy = (phi[:,1:] - phi[:,:-1])/(yy[nuax,1:] - yy[nuax,:-1])
        c1_yy = (phi[:,:-1] - s_yy*yy[nuax,:-1])/(ny+1)

        term1_yy = np.dot(dbeta1_yy,c1_yy.T)
        term2_yy = np.dot(dbeta2_yy, s_yy.T)
        term2_yy *= np.arange(1,ny+2)[:,np.newaxis]/((ny+1)*(ny+2))
        over_y_all = term1_yy + term2_yy

        s_xx_all = (over_y_all[:,1:] - over_y_all[:,:-1])/(xx[1:]-xx[:-1])
        c1_xx_all = (over_y_all[:,:-1] - s_xx_all*xx[:-1])/(nx+1)

        term1_all = np.dot(dbeta1_xx, c1_xx_all.T)
        term2_all = np.dot(dbeta2_xx, s_xx_all.T)
        term2_all *=  np.arange(1,nx+2)[:,np.newaxis]/((nx+1)*(nx+2))

        data = term1_all + term2_all

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_direct(nx, ny, nz, xx, yy, zz, phi, mask_corners=True,
                     het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1, ny+1, nz+1))
    
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
        half_dx = dx/2.0
    
        # We cache these calculations...
        factorx_cache, factory_cache = {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
    
        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zz**kk * (1-zz)**(nz-kk)
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            over_z = trapz(factorz[nuax, nuax,:] * phi, dx=dz)
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                over_y = trapz(factory * over_z, dx=dy)
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    # It&#39;s faster here to do the trapezoid rule explicitly
                    # rather than using SciPy&#39;s more general routine.
                    integrand = factorx * over_y
                    ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                    data[ii,jj,kk] = ans
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_4D_direct(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True,
                     het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1, ny+1, nz+1, na+1))
    
        dx, dy, dz, da = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz), np.diff(aa)
        half_dx = dx/2.0
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache = {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zz**kk * (1-zz)**(nz-kk)
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            factorz_cache[nz,kk] = factorz[nuax,nuax,:]
    
        for ll in range(0, na+1):
            factora = comb(na, ll) * aa**ll * (1-aa)**(na-ll)
            if het_ascertained == &#39;aa&#39;:
                factora *= aa*(1-aa)
            over_a = trapz(factora[nuax,nuax,nuax,:] * phi, dx=da)
            for kk in range(0, nz+1):
                factorz = factorz_cache[nz,kk]
                over_z = trapz(factorz * over_a, dx=dz)
                for jj in range(0, ny+1):
                    factory = factory_cache[ny,jj]
                    over_y = trapz(factory * over_z, dx=dy)
                    for ii in range(0, nx+1):
                        factorx = factorx_cache[nx,ii]
                        # It&#39;s faster here to do the trapezoid rule explicitly
                        # rather than using SciPy&#39;s more general routine.
                        integrand = factorx * over_y
                        ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                        data[ii,jj,kk,ll] = ans
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_direct_inbreeding(nx, ny, nz, xx, yy, zz, phi, Fx, Fy, Fz,
                                       mask_corners=True, ploidyx=2, ploidyy=2, ploidyz=2,
                                       het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        if nx % ploidyx == 0:
            nIndx = nx/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 1.&#39;.format(str(nx),str(ploidyx)))
        
        if ny % ploidyy == 0:
            nIndy = ny/ploidyy
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 2.&#39;.format(str(ny),str(ploidyy)))
        
        if nz % ploidyz == 0:
            nIndz = nz/ploidyz
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 3.&#39;.format(str(nz),str(ploidyz)))
        
        data = numpy.zeros((nx+1, ny+1, nz+1))
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
        half_dx = dx/2.0
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        alphay = yy*((1.0-Fy)/Fy)
        alphay[0],alphay[-1] = 1.0e-20*((1.0-Fy)/Fy), (1.0-1.0e-20)*((1.0-Fy)/Fy)
        betay = (1.0-yy)*((1.0-Fy)/Fy)
        betay[0],betay[-1] = (1.0-1.0e-20)*((1.0-Fy)/Fy), 1.0e-20*((1.0-Fy)/Fy)
        alphaz = zz*((1.0-Fz)/Fz)
        alphaz[0],alphaz[-1] = 1.0e-20*((1.0-Fz)/Fz), (1.0-1.0e-20)*((1.0-Fz)/Fz)
        betaz = (1.0-zz)*((1.0-Fz)/Fz)
        betaz[0],betaz[-1] = (1.0-1.0e-20)*((1.0-Fz)/Fz), 1.0e-20*((1.0-Fz)/Fz)
        
        # We cache these calculations...
        factorx_cache, factory_cache = {}, {}
        for ii in range(0, nx+1):
            factorx = numpy.array([BetaBinomConvolution(ii,nIndx,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))])
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = numpy.array([BetaBinomConvolution(jj,nIndy,alphay[j],betay[j],ploidy=ploidyy) for j in range(0,len(yy))])
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
        
        for kk in range(0, nz+1):
            factorz = numpy.array([BetaBinomConvolution(kk,nIndz,alphaz[j],betaz[j],ploidy=ploidyz) for j in range(0,len(zz))])
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            over_z = trapz(factorz[nuax, nuax,:] * phi, dx=dz)
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                over_y = trapz(factory * over_z, dx=dy)
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    # It&#39;s faster here to do the trapezoid rule explicitly
                    # rather than using SciPy&#39;s more general routine.
                    integrand = factorx * over_y
                    ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                    data[ii,jj,kk] = ans
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_admix_props(nx, ny, nz, xx, yy, zz, phi, mask_corners=True,
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        if admix_props is None:
            admix_props = ((1,0,0), (0,1,0), (0,0,1))

        xadmix = admix_props[0][0]*xx[:,nuax,nuax]\
                + admix_props[0][1]*yy[nuax,:,nuax]\
                + admix_props[0][2]*zz[nuax,nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax,nuax]\
                + admix_props[1][1]*yy[nuax,:,nuax]\
                + admix_props[1][2]*zz[nuax,nuax,:]
        zadmix = admix_props[2][0]*xx[:,nuax,nuax]\
                + admix_props[2][1]*yy[nuax,:,nuax]\
                + admix_props[2][2]*zz[nuax,nuax,:]

        data = numpy.zeros((nx+1, ny+1, nz+1))
    
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache = {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx

        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            factory_cache[ny,jj] = factory

        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zadmix**kk * (1-zadmix)**(nz-kk)
            factorz_cache[nz,kk] = factorz
    
        for kk in range(0, nz+1):
            factorz = factorz_cache[nz,kk]
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    over_z = trapz(factorz * factory * factorx * phi, dx=dz)
                    over_y = trapz(over_z, dx=dy)
                    data[ii,jj,kk] = trapz(over_y, dx=dx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_linalg(nx, ny, nz, xx, yy, zz, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1))

        dbeta1_zz, dbeta2_zz = cached_dbeta(nz, zz)

        # Quick testing suggests that doing the x direction first for better
        # memory alignment isn&#39;t worth much.
        s_zz = (phi[:,:,1:]-phi[:,:,:-1])/(zz[nuax,nuax,1:]-zz[nuax,nuax,:-1])
        c1_zz = (phi[:,:,:-1] - s_zz*zz[nuax,nuax,:-1])/(nz+1)
        # These calculations can be done without this for loop, but the
        # four-dimensional intermediate results consume massive amounts of RAM,
        # which makes the for loop faster for large systems.
        for kk in range(0, nz+1):
            # In testing, these two np.dot lines occupy 2/3 the time, so further
            # speedup will be difficult
            term1 = np.dot(c1_zz, dbeta1_zz[kk])
            term2 = np.dot(s_zz, dbeta2_zz[kk])
            term2 *= (kk+1)/((nz+1)*(nz+2))
            over_z = term1 + term2

            sub_fs = Spectrum._from_phi_2D_linalg(nx, ny, xx, yy, over_z, raw=True)
            data[:,:,kk] = sub_fs.data

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_5D_linalg(nx, ny, nz, na, nb, xx, yy, zz, aa, bb, phi, mask_corners=True):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1,na+1,nb+1))

        dbeta1_bb, dbeta2_bb = cached_dbeta(nb, bb)

        s_bb = (phi[:,:,:,:,1:]-phi[:,:,:,:,:-1])/(bb[nuax,nuax,nuax,nuax,1:]-bb[nuax,nuax,nuax,nuax:-1])
        c1_bb = (phi[:,:,:,:,:-1] - s_bb*bb[nuax,nuax,nuax,nuax,:-1])/(nb+1)
        for mm in range(0, nb+1):
            term1 = np.dot(c1_bb, dbeta1_bb[mm])
            term2 = np.dot(s_bb, dbeta2_bb[mm])
            term2 *= (mm+1)/((nb+1)*(nb+2))
            over_b = term1 + term2

            sub_fs = Spectrum._from_phi_4D_linalg(nx, ny, nz, na, xx, yy, zz, aa, over_b, raw=True)
            data[:,:,:,:,mm] = sub_fs.data

        fs = dadi.Spectrum(data, mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_phi_4D_linalg(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1,na+1))

        dbeta1_aa, dbeta2_aa = cached_dbeta(na, aa)

        s_aa = (phi[:,:,:,1:]-phi[:,:,:,:-1])/(aa[nuax,nuax,nuax,1:]-aa[nuax,nuax,nuax:-1])
        c1_aa = (phi[:,:,:,:-1] - s_aa*aa[nuax,nuax,nuax,:-1])/(na+1)
        for ll in range(0, na+1):
            term1 = np.dot(c1_aa, dbeta1_aa[ll])
            term2 = np.dot(s_aa, dbeta2_aa[ll])
            term2 *= (ll+1)/((na+1)*(na+2))
            over_a = term1 + term2

            sub_fs = Spectrum._from_phi_3D_linalg(nx, ny, nz, xx, yy, zz, over_a, raw=True)
            data[:,:,:,ll] = sub_fs.data

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_4D_admix_props(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True,
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        if admix_props is None:
            admix_props = ((1,0,0,0), (0,1,0,0), (0,0,1,0), (0,0,0,1))

        xadmix = admix_props[0][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[0][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[0][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[0][3]*aa[nuax,nuax,nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[1][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[1][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[1][3]*aa[nuax,nuax,nuax,:]
        zadmix = admix_props[2][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[2][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[2][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[2][3]*aa[nuax,nuax,nuax,:]
        aadmix = admix_props[3][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[3][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[3][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[3][3]*aa[nuax,nuax,nuax,:]

        data = numpy.zeros((nx+1, ny+1, nz+1, na+1))
    
        dx, dy, dz, da = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz), numpy.diff(aa)
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache, factora_cache = {}, {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx

        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            factory_cache[ny,jj] = factory

        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zadmix**kk * (1-zadmix)**(nz-kk)
            factorz_cache[nz,kk] = factorz

        for ll in range(0, na+1):
            factora = comb(na, ll) * aadmix**ll * (1-aadmix)**(na-ll)
            factora_cache[na,ll] = factora
    
        for ll in range(0, na+1):
            factora = factora_cache[na,ll]
            for kk in range(0, nz+1):
                factorz = factorz_cache[nz,kk]
                for jj in range(0, ny+1):
                    factory = factory_cache[ny,jj]
                    for ii in range(0, nx+1):
                        factorx = factorx_cache[nx,ii]
                        over_a = trapz(factora * factorz * factory * factorx * phi, dx=da)
                        over_z = trapz(over_a, dx=dz)
                        over_y = trapz(over_z, dx=dy)
                        data[ii,jj,kk,ll] = trapz(over_y, dx=dx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def from_phi(phi, ns, xxs, mask_corners=True, 
                 pop_ids=None, admix_props=None, het_ascertained=None, 
                 force_direct=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        phi: P-dimensional population frequency distribution.
        ns: Sequence of P sample sizes for each population.
        xxs: Sequence of P one-dimesional grids on which phi is defined.
        mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                      entries.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        admix_props: Admixture proportions for sampled individuals. For example,
                     if there are two populations, and individuals from the
                     first pop are admixed with fraction f from the second
                     population, then admix_props=((1-f,f),(0,1)). For three
                     populations, the no-admixture setting is
                     admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method.)
        het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                         population 2 or 3, respectively.
                         been ascertained by being heterozygous in one
                         individual from population 1. (This individual is
                         *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                         assumed that the ascertainment individual came from
                         population 2 or 3, respectively.
                         (Note that this option also forces direct integration,
                         which may be less accurate than the semi-analytic
                         method. This could be fixed if there is interest. Note
                         also that this option cannot be used simultaneously
                         with admix_props.)
        force_direct: Forces integration to use older direct integration method,
                      rather than using analytic integration of sampling 
                      formula.
        &#34;&#34;&#34;
        if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
            raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                             &#39;populations.&#39; .format(str(admix_props)))
        if not phi.ndim == len(ns) == len(xxs):
            raise ValueError(&#39;Dimensionality of phi and lengths of ns and xxs &#39;
                             &#39;do not all agree.&#39;)
        if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
            raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                             &#34;&#39;zz&#39;.&#34;)

        if admix_props and het_ascertained:
            error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
            simultaneously. Instead, please use the PhiManip methods to 
            implement admixture. If this proves inappropriate for your use, 
            contact the the dadi developers, as it may be possible to support
            both options simultaneously in the future.&#34;&#34;&#34;
            raise NotImplementedError(error)

        if phi.ndim == 1:
            if not het_ascertained and not force_direct:
                fs = Spectrum._from_phi_1D_analytic(ns[0], xxs[0], phi,
                                                    mask_corners)
            else:
                fs = Spectrum._from_phi_1D_direct(ns[0], xxs[0], phi, 
                                                  mask_corners, het_ascertained)
        elif phi.ndim == 2:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_2D_linalg(ns[0], ns[1], 
                                                  xxs[0], xxs[1], phi,
                                                  mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_2D_direct(ns[0], ns[1], xxs[0], xxs[1], 
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_2D_admix_props(ns[0], ns[1], 
                                                      xxs[0], xxs[1], 
                                                      phi, mask_corners, 
                                                      admix_props)
        elif phi.ndim == 3:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_3D_linalg(ns[0], ns[1], ns[2], 
                                                  xxs[0], xxs[1], xxs[2],
                                                  phi, mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_3D_direct(ns[0], ns[1], ns[2], 
                                                  xxs[0], xxs[1], xxs[2], 
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_3D_admix_props(ns[0], ns[1], ns[2], 
                                                       xxs[0], xxs[1], xxs[2], 
                                                       phi, mask_corners, 
                                                       admix_props)
        elif phi.ndim == 4:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_4D_linalg(ns[0], ns[1], ns[2], ns[3],
                                                  xxs[0], xxs[1], xxs[2], xxs[3],
                                                  phi, mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_4D_direct(ns[0], ns[1], ns[2], ns[3],
                                                  xxs[0], xxs[1], xxs[2], xxs[3],
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_4D_admix_props(ns[0], ns[1], ns[2], ns[3],
                                                       xxs[0], xxs[1], xxs[2], xxs[3],
                                                       phi, mask_corners, 
                                                       admix_props)
        elif phi.ndim == 5:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_5D_linalg(ns[0], ns[1], ns[2], ns[3], ns[4],
                                                  xxs[0], xxs[1], xxs[2], xxs[3], xxs[4],
                                                  phi, mask_corners)
        else:
            raise ValueError(&#39;Only implemented for dimensions 1-5.&#39;)
        fs.pop_ids = pop_ids
        # Record value to use for extrapolation. This is the first grid point,
        # which is where new mutations are introduced. Note that extrapolation
        # will likely fail if grids differ between dimensions.
        fs.extrap_x = xxs[0][1]
        for xx in xxs[1:]:
            if not xx[1] == fs.extrap_x:
                logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                            &#39;different dimensions. Extrapolation may fail.&#39;)
        return fs

    @staticmethod
    def from_phi_inbreeding(phi, ns, xxs, Fs, ploidys, mask_corners=True, 
                            pop_ids=None, admix_props=None,
                            het_ascertained=None, force_direct=True):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        phi: P-dimensional population frequency distribution.
        ns: Sequence of P sample sizes for each population.
        xxs: Sequence of P one-dimesional grids on which phi is defined.
        Fs: Sequence of P inbreeding coefficients for each population.
        ploidys: Sequence of P ploidy levels for each population.
        mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                      entries.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        admix_props: Admixture proportions for sampled individuals. For example,
                     if there are two populations, and individuals from the
                     first pop are admixed with fraction f from the second
                     population, then admix_props=((1-f,f),(0,1)). For three
                     populations, the no-admixture setting is
                     admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method.)
        het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                         been ascertained by being heterozygous in one
                         individual from population 1. (This individual is
                         *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                         assumed that the ascertainment individual came from
                         population 2 or 3, respectively.
                         (Note that this option also forces direct integration,
                         which may be less accurate than the semi-analytic
                         method. This could be fixed if there is interest. Note
                         also that this option cannot be used simultaneously
                         with admix_props.)
        force_direct: Forces integration to use older direct integration method,
                      rather than using analytic integration of sampling 
                      formula.
        &#34;&#34;&#34;
        if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
            raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                             &#39;populations.&#39; .format(str(admix_props)))
        if not phi.ndim == len(ns) == len(xxs) == len(Fs) == len(ploidys):
            raise ValueError(&#39;Dimensionality of phi and lengths of ns, xxs, ploidys, and Fs &#39;
                             &#39;do not all agree.&#39;)
        if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
            raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                             &#34;&#39;zz&#39;.&#34;)

        if admix_props and het_ascertained:
            error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
            simultaneously. Instead, please use the PhiManip methods to 
            implement admixture. If this proves inappropriate for your use, 
            contact the the dadi developers, as it may be possible to support
            both options simultaneously in the future.&#34;&#34;&#34;
            raise NotImplementedError(error)

        if phi.ndim == 1:
            fs = Spectrum._from_phi_1D_direct_inbreeding(ns[0], xxs[0], phi, Fs[0],
                                                         mask_corners, ploidys[0],
                                                         het_ascertained)
        elif phi.ndim == 2:
            fs = Spectrum._from_phi_2D_direct_inbreeding(ns[0], ns[1], xxs[0], xxs[1],
                                                         phi, Fs[0], Fs[1], mask_corners,
                                                         ploidys[0], ploidys[1],
                                                         het_ascertained)
        elif phi.ndim == 3:
            fs = Spectrum._from_phi_3D_direct_inbreeding(ns[0], ns[1], ns[2], 
                                                         xxs[0], xxs[1], xxs[2], 
                                                         phi, Fs[0], Fs[1], Fs[2],
                                                         mask_corners, ploidys[0],
                                                         ploidys[1], ploidys[2],
                                                         het_ascertained)
        else:
            raise ValueError(&#39;Only implemented for dimensions 1,2 or 3.&#39;)
        fs.pop_ids = pop_ids
        # Record value to use for extrapolation. This is the first grid point,
        # which is where new mutations are introduced. Note that extrapolation
        # will likely fail if grids differ between dimensions.
        fs.extrap_x = xxs[0][1]
        for xx in xxs[1:]:
            if not xx[1] == fs.extrap_x:
                logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                            &#39;different dimensions. Extrapolation may fail.&#39;)
        return fs

    def scramble_pop_ids(self, mask_corners=True):
        &#34;&#34;&#34;
        Spectrum corresponding to scrambling individuals among populations.
        
        This is useful for assessing how diverged populations are.
        Essentially, it pools all the individuals represented in the fs and
        generates new populations of random individuals (without replacement)
        from that pool. If this fs is significantly different from the
        original, that implies population structure.
        &#34;&#34;&#34;
        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # projecting.
        if original_folded:
            self = self.unfold()

        total_samp = numpy.sum(self.sample_sizes)
    
        # First generate a 1d sfs for the pooled population.
        combined = numpy.zeros(total_samp+1)
        # For each entry in the fs, this is the total number of derived alleles
        total_per_entry = self._total_per_entry()
        # Sum up to generate the equivalent 1-d spectrum.
        for derived,counts in zip(total_per_entry.ravel(), self.ravel()):
            combined[derived] += counts
    
        # Now resample back into a n-d spectrum
        # For each entry, this is the counts per popuation. 
        #  e.g. counts_per_entry[3,4,5] = [3,4,5]
        counts_per_entry = self._counts_per_entry()
        # Reshape it to be 1-d, so we can iterate over it easily.
        counts_per_entry = counts_per_entry.reshape(numpy.prod(self.shape), 
                                                    self.ndim)
        resamp = numpy.zeros(self.shape)
        for counts, derived in zip(counts_per_entry, total_per_entry.ravel()):
            # The probability here is 
            # (t1 choose d1)*(t2 choose d2)/(ntot choose derived)
            lnprob = sum(_lncomb(t,d) for t,d in zip(self.sample_sizes,counts))
            lnprob -= _lncomb(total_samp, derived)
            prob = numpy.exp(lnprob)
            # Assign result using the appropriate weighting
            resamp[tuple(counts)] += prob*combined[derived]

        resamp = Spectrum(resamp, mask_corners=mask_corners)
        if not original_folded:
            return resamp
        else:
            return resamp.fold()

    @staticmethod
    def from_data_dict(data_dict, pop_ids, projections, mask_corners=True,
                       polarized=True):
        &#34;&#34;&#34;
        Spectrum from a dictionary of polymorphisms.

        pop_ids: list of which populations to make fs for.
        projections: list of sample sizes to project down to for each
                     population.
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked.
        polarized: If True, the data are assumed to be correctly polarized by 
                   `outgroup_allele&#39;. SNPs in which the &#39;outgroup_allele&#39;
                   information is missing or &#39;-&#39; or not concordant with the
                   segregating alleles will be ignored.
                   If False, any &#39;outgroup_allele&#39; info present is ignored,
                   and the returned spectrum is folded.

        The data dictionary should be organized as:
            {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                     &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                                &#39;CEU&#39;: (7,3)
                                },
                     &#39;outgroup_allele&#39;: &#39;T&#39;
                    }
            }
        The &#39;calls&#39; entry gives the successful calls in each population, in the
        order that the alleles are specified in &#39;segregating&#39;.
        Non-diallelic polymorphisms are skipped.
        &#34;&#34;&#34;
        import dadi.Misc
        cd = dadi.Misc.count_data_dict(data_dict, pop_ids)
        fs = Spectrum._from_count_dict(cd, projections, polarized, pop_ids, 
                mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_count_dict(count_dict, projections, polarized=True, pop_ids=None,
            mask_corners=False):
        &#34;&#34;&#34;
        Frequency spectrum from data mapping SNP configurations to counts.

        count_dict: Result of Misc.count_data_dict
        projections: List of sample sizes to project down to for each
                     population.
        polarized: If True, only include SNPs that count_dict marks as
                   polarized.
                   If False, include all SNPs and fold resulting Spectrum.
        pop_ids: Optional list of strings containing the population labels.
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked.
        &#34;&#34;&#34;
        # create slices for projection calculation
        slices = [[numpy.newaxis] * len(projections) for ii in
                  range(len(projections))]
        for ii in range(len(projections)):
            slices[ii][ii] = slice(None,None,None)
        # Convert to tuples to avoid numpy error
        slices = [tuple(_) for _ in slices]

        fs_total = dadi.Spectrum(numpy.zeros(numpy.array(projections)+1),
                                 pop_ids=pop_ids, mask_corners=mask_corners)
        for (called_by_pop, derived_by_pop, this_snp_polarized), count\
                in count_dict.items():
            if polarized and not this_snp_polarized:
                continue
            pop_contribs = []
            iter = zip(projections, called_by_pop, derived_by_pop)
            for pop_ii, (p_to, p_from, hits) in enumerate(iter):
                contrib = _cached_projection(p_to,p_from,hits)[slices[pop_ii]]
                pop_contribs.append(contrib)
            fs_proj = pop_contribs[0]
            for contrib in pop_contribs[1:]:
                fs_proj = fs_proj*contrib

            # create slices for adding projected fs to overall fs
            fs_total += count * fs_proj
        if polarized:
            return fs_total
        else:
            return fs_total.fold()

    @staticmethod
    def _data_by_tri(data_dict):
        &#34;&#34;&#34;
        Nest the data by derived context and outgroup base.

        The resulting dictionary contains only SNPs which are appropriate for
        use of Hernandez&#39;s ancestral misidentification correction. It is
        organized as {(derived_tri, outgroup_base): {snp_id: data,...}}
        &#34;&#34;&#34;
        result = {}
        genetic_bases = &#39;ACTG&#39;
        for snp, snp_info in data_dict.items():
            # Skip non-diallelic polymorphisms
            if len(snp_info[&#39;segregating&#39;]) != 2:
                continue
            allele1, allele2 = snp_info[&#39;segregating&#39;]
            # Filter out SNPs where we either non-constant ingroup or outgroup
            # context.
            try:
                ingroup_tri = snp_info[&#39;context&#39;]
                outgroup_tri = snp_info[&#39;outgroup_context&#39;]
            except KeyError:
                continue
            if not outgroup_tri[1] == snp_info[&#39;outgroup_allele&#39;]:
                raise ValueError(&#39;Outgroup context and allele are inconsistent &#39;
                                 &#39;for polymorphism: %s.&#39; % snp)
            outgroup_allele = outgroup_tri[1]
    
            # These are all the requirements to apply the ancestral correction.
            # First 2 are constant context.
            # Next 2 are sensible context.
            # Next 1 is that outgroup allele is one of the segregating.
            # Next 2 are that segregating alleles are sensible.
            if outgroup_tri[0] != ingroup_tri[0]\
               or outgroup_tri[2] != ingroup_tri[2]\
               or ingroup_tri[0] not in genetic_bases\
               or ingroup_tri[2] not in genetic_bases\
               or outgroup_allele not in [allele1, allele2]\
               or allele1 not in genetic_bases\
               or allele2 not in genetic_bases:
                continue
    
            if allele1 == outgroup_allele:
                derived_allele = allele2
            elif allele2 == outgroup_allele:
                # In this case, the second allele is non_outgroup
                derived_allele = allele1
            derived_tri = ingroup_tri[0] + derived_allele + ingroup_tri[2]
            result.setdefault((derived_tri, outgroup_allele), {})
            result[derived_tri, outgroup_allele][snp] = snp_info
        return result
    
    @staticmethod
    def from_data_dict_corrected(data_dict, pop_ids, projections,
                                 fux_filename, force_pos=True,
                                 mask_corners=True):
        &#34;&#34;&#34;
        Spectrum from a dictionary of polymorphisms, corrected for ancestral
        misidentification.

        The correction is based upon:
            Hernandez, Williamson &amp; Bustamante _Mol_Biol_Evol_ 24:1792 (2007)

        force_pos: If the correction is too agressive, it may leave some small
                   entries in the fs less than zero. If force_pos is true,
                   these entries will be set to zero, in such a way that the
                   total number of segregating SNPs is conserved.
        fux_filename: The name of the file containing the 
                   misidentification probabilities.
                   The file is of the form:
                       # Any number of comments lines beginning with #
                       AAA T 0.001
                       AAA G 0.02
                       ...
                   Where every combination of three + one bases is considered
                   (order is not important).  The triplet is the context and
                   putatively derived allele (x) in the reference species. The
                   single base is the base (u) in the outgroup. The numerical
                   value is 1-f_{ux} in the notation of the paper.

        The data dictionary should be organized as:
            {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                     &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                                &#39;CEU&#39;: (7,3)
                                },
                     &#39;outgroup_allele&#39;: &#39;T&#39;,
                     &#39;context&#39;: &#39;CAT&#39;,
                     &#39;outgroup_context&#39;: &#39;CAT&#39;
                    }
            }
        The additional entries are &#39;context&#39;, which includes the two flanking
        bases in the species of interest, and &#39;outgroup_context&#39;, which
        includes the aligned bases in the outgroup.

        This method skips entries for which the correction cannot be applied.
        Most commonly this is because of missing or non-constant context.
        &#34;&#34;&#34;
        # Read the fux file into a dictionary.
        fux_dict = {}
        f = open(fux_filename)
        for line in f.readlines():
            if line.startswith(&#39;#&#39;):
                continue
            sp = line.split()
            fux_dict[(sp[0], sp[1])] = 1-float(sp[2])
        f.close()
    
        # Divide the data into classes based on (&#39;context&#39;, &#39;outgroup_allele&#39;)
        by_context = Spectrum._data_by_tri(data_dict)
    
        fs = numpy.zeros(numpy.asarray(projections)+1)
        while by_context:
            # Each time through this loop, we eliminate two entries from the 
            # data dictionary. These correspond to one class and its
            # corresponding misidentified class.
            (derived_tri, out_base), nomis_data = by_context.popitem()

            # The corresponding bases if the ancestral state had been
            # misidentifed.
            mis_out_base = derived_tri[1]
            mis_derived_tri = derived_tri[0] + out_base + derived_tri[2]
            # Get the data for that case. Note that we default to an empty
            # dictionary if we don&#39;t have data for that class.
            mis_data = by_context.pop((mis_derived_tri, mis_out_base), {})
    
            fux = fux_dict[(derived_tri, out_base)]
            fxu = fux_dict[(mis_derived_tri, mis_out_base)]
    
            # Get the spectra for these two cases
            Nux = Spectrum.from_data_dict(nomis_data, pop_ids, projections)
            Nxu = Spectrum.from_data_dict(mis_data, pop_ids, projections)
    
            # Equations 5 &amp; 6 from the paper.
            Nxu_rev = reverse_array(Nxu)
            Rux = (fxu*Nux - (1-fxu)*Nxu_rev)/(fux+fxu-1)
            Rxu = reverse_array((fux*Nxu_rev - (1-fux)*Nux)/(fux+fxu-1))
    
            fs += Rux + Rxu
    
        # Here we take the negative entries, and flip them back, so they end up
        # zero and the total number of SNPs is conserved.
        if force_pos:
            negative_entries = numpy.minimum(0, fs)
            fs -= negative_entries
            fs += reverse_array(negative_entries)
    
        return Spectrum(fs, mask_corners=mask_corners, pop_ids=pop_ids)

    # The code below ensures that when I do arithmetic with Spectrum objects,
    # it is not done between a folded and an unfolded array. If it is, I raise
    # a ValueError.

    # While I&#39;m at it, I&#39;m also fixing the annoying behavior that if a1 and a2
    # are masked arrays, and a3 = a1 + a2. Then wherever a1 or a2 was masked,
    # a3.data ends up with the a1.data values, rather than a1.data + a2.data.
    # Note that this fix doesn&#39;t work for operation by numpy.ma.exp and 
    # numpy.ma.log. Guess I can&#39;t have everything.

    # I&#39;m using exec here to avoid copy-pasting a dozen boiler-plate functions.
    # The calls to check_folding_equal ensure that we don&#39;t try to combine
    # folded and unfolded Spectrum objects.

    # I set check_folding = False in the constructor because it raises useless
    # warnings when, for example, I do (model + 1). 

    # These functions also ensure that the pop_ids and extrap_x attributes
    # get properly copied over.

    # This is pretty advanced Python voodoo, so don&#39;t fret if you don&#39;t
    # understand it at first glance. :-)
    for method in [&#39;__add__&#39;,&#39;__radd__&#39;,&#39;__sub__&#39;,&#39;__rsub__&#39;,&#39;__mul__&#39;,
                   &#39;__rmul__&#39;,&#39;__div__&#39;,&#39;__rdiv__&#39;,&#39;__truediv__&#39;,&#39;__rtruediv__&#39;,
                   &#39;__floordiv__&#39;,&#39;__rfloordiv__&#39;,&#39;__rpow__&#39;,&#39;__pow__&#39;]:
        exec(&#34;&#34;&#34;
def %(method)s(self, other):
    self._check_other_folding(other)
    if isinstance(other, numpy.ma.masked_array):
        newdata = self.data.%(method)s (other.data)
        newmask = numpy.ma.mask_or(self.mask, other.mask)
    else:
        newdata = self.data.%(method)s (other)
        newmask = self.mask
    newpop_ids = self.pop_ids
    if hasattr(other, &#39;pop_ids&#39;):
        if other.pop_ids is None:
            newpop_ids = self.pop_ids
        elif self.pop_ids is None:
            newpop_ids = other.pop_ids
        elif other.pop_ids != self.pop_ids:
            logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;
                        &#39;Resulting pop_id may not be correct.&#39;)
    if hasattr(other, &#39;extrap_x&#39;) and self.extrap_x != other.extrap_x:
        extrap_x = None
    else:
        extrap_x = self.extrap_x
    outfs = self.__class__.__new__(self.__class__, newdata, newmask, 
                                   mask_corners=False, data_folded=self.folded,
                                   check_folding=False, pop_ids=newpop_ids,
                                   extrap_x=extrap_x)
    return outfs
&#34;&#34;&#34; % {&#39;method&#39;:method})

    # Methods that modify the Spectrum in-place.
    for method in [&#39;__iadd__&#39;,&#39;__isub__&#39;,&#39;__imul__&#39;,&#39;__idiv__&#39;,
                   &#39;__itruediv__&#39;,&#39;__ifloordiv__&#39;,&#39;__ipow__&#39;]:
        exec(&#34;&#34;&#34;
def %(method)s(self, other):
    self._check_other_folding(other)
    if isinstance(other, numpy.ma.masked_array):
        self.data.%(method)s (other.data)
        self.mask = numpy.ma.mask_or(self.mask, other.mask)
    else:
        self.data.%(method)s (other)
    if hasattr(other, &#39;pop_ids&#39;) and other.pop_ids is not None\
             and other.pop_ids != self.pop_ids:
        logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;
                    &#39;Resulting pop_id may not be correct.&#39;)
    if hasattr(other, &#39;extrap_x&#39;) and self.extrap_x != other.extrap_x:
        self.extrap_x = None
    return self
&#34;&#34;&#34; % {&#39;method&#39;:method})

    def _check_other_folding(self, other):
        &#34;&#34;&#34;
        Ensure other Spectrum has same .folded status
        &#34;&#34;&#34;
        if isinstance(other, self.__class__)\
           and other.folded != self.folded:
            raise ValueError(&#39;Cannot operate with a folded Spectrum and an &#39;
                             &#39;unfolded one.&#39;)

# Allow spectrum objects to be pickled. 
# See http://effbot.org/librarybook/copy-reg.htm
try:
    import copyreg
except:
    # For Python 2.x compatibility
    import copy_reg as copyreg
def Spectrum_unpickler(data, mask, data_folded, pop_ids, extrap_x):
    return dadi.Spectrum(data, mask, mask_corners=False, data_folded=data_folded, check_folding=False, pop_ids=pop_ids, extrap_x=extrap_x)
def Spectrum_pickler(fs):
    return Spectrum_unpickler, (fs.data, fs.mask, fs.folded, fs.pop_ids, fs.extrap_x)
copyreg.pickle(Spectrum, Spectrum_pickler, Spectrum_unpickler)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum_pickler"><code class="name flex">
<span>def <span class="ident">Spectrum_pickler</span></span>(<span>fs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Spectrum_pickler(fs):
    return Spectrum_unpickler, (fs.data, fs.mask, fs.folded, fs.pop_ids, fs.extrap_x)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum_unpickler"><code class="name flex">
<span>def <span class="ident">Spectrum_unpickler</span></span>(<span>data, mask, data_folded, pop_ids, extrap_x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Spectrum_unpickler(data, mask, data_folded, pop_ids, extrap_x):
    return dadi.Spectrum(data, mask, mask_corners=False, data_folded=data_folded, check_folding=False, pop_ids=pop_ids, extrap_x=extrap_x)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.cached_dbeta"><code class="name flex">
<span>def <span class="ident">cached_dbeta</span></span>(<span>nx, xx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cached_dbeta(nx, xx):
    key = nx, tuple(xx)

    xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)
    if key not in _dbeta_cache:
        dbeta1 = np.empty((nx+1,len(xx)-1))
        dbeta2 = np.empty((nx+1,len(xx)-1))
        for ii in range(0, nx+1):
            b = betainc(ii+1,nx-ii+1,xx)
            dbeta1[ii] = b[1:]-b[:-1]
            b = betainc(ii+2,nx-ii+1,xx)
            dbeta2[ii] = b[1:]-b[:-1]
        _dbeta_cache[key] = dbeta1, dbeta2
    dbeta1, dbeta2 = _dbeta_cache[key]
    return dbeta1, dbeta2</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum"><code class="flex name class">
<span>class <span class="ident">Spectrum</span></span>
<span>(</span><span>data, mask=False, mask_corners=True, data_folded=None, check_folding=True, dtype=builtins.float, copy=True, fill_value=nan, keep_mask=True, shrink=True, pop_ids=None, extrap_x=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a frequency spectrum.</p>
<p>Spectra are represented by masked arrays. The masking allows us to ignore
specific entries in the spectrum. Most often, these are the absent and fixed
categories.</p>
<p>The constructor has the format:
fs = dadi.Spectrum(data, mask, mask_corners, data_folded, check_folding,
pop_ids, extrap_x)</p>
<pre><code>data: The frequency spectrum data
mask: An optional array of the same size as data. 'True' entires in
      this array are masked in the Spectrum. These represent missing
      data categories. (For example, you may not trust your singleton
      SNP calling.)
mask_corners: If True (default), the 'observed in none' and 'observed 
              in all' entries of the FS will be masked. Typically these
              entries are unobservable, and dadi cannot reliably
              calculate them, so you will almost always want
              mask_corners=True.g
data_folded: If True, it is assumed that the input data is folded. An
             error will be raised if the input data and mask are not
             consistent with a folded Spectrum.
check_folding: If True and data_folded=True, the data and mask will be
               checked to ensure they are consistent with a folded
               Spectrum. If they are not, a warning will be printed.
pop_ids: Optional list of strings containing the population labels.
extrap_x: Optional floating point value specifying x value to use
          for extrapolation.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spectrum(numpy.ma.masked_array):
    &#34;&#34;&#34;
    Represents a frequency spectrum.

    Spectra are represented by masked arrays. The masking allows us to ignore
    specific entries in the spectrum. Most often, these are the absent and fixed
    categories.

    The constructor has the format:
        fs = dadi.Spectrum(data, mask, mask_corners, data_folded, check_folding,
                           pop_ids, extrap_x)
        
        data: The frequency spectrum data
        mask: An optional array of the same size as data. &#39;True&#39; entires in
              this array are masked in the Spectrum. These represent missing
              data categories. (For example, you may not trust your singleton
              SNP calling.)
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked. Typically these
                      entries are unobservable, and dadi cannot reliably
                      calculate them, so you will almost always want
                      mask_corners=True.g
        data_folded: If True, it is assumed that the input data is folded. An
                     error will be raised if the input data and mask are not
                     consistent with a folded Spectrum.
        check_folding: If True and data_folded=True, the data and mask will be
                       checked to ensure they are consistent with a folded
                       Spectrum. If they are not, a warning will be printed.
        pop_ids: Optional list of strings containing the population labels.
        extrap_x: Optional floating point value specifying x value to use
                  for extrapolation.
    &#34;&#34;&#34;
    def __new__(subtype, data, mask=numpy.ma.nomask, mask_corners=True, 
                data_folded=None, check_folding=True, dtype=float, copy=True, 
                fill_value=numpy.nan, keep_mask=True, shrink=True, 
                pop_ids=None, extrap_x=None):
        data = numpy.asanyarray(data)

        if mask is numpy.ma.nomask:
            mask = numpy.ma.make_mask_none(data.shape)

        subarr = numpy.ma.masked_array(data, mask=mask, dtype=dtype, copy=copy,
                                       fill_value=fill_value, keep_mask=True, 
                                       shrink=True)
        subarr = subarr.view(subtype)

        if hasattr(data, &#39;folded&#39;):
            if data_folded is None or data_folded == data.folded:
                subarr.folded = data.folded
            elif data_folded != data.folded:
                raise ValueError(&#39;Data does not have same folding status as &#39;
                                 &#39;was called for in Spectrum constructor.&#39;)
        elif data_folded is not None:
            subarr.folded = data_folded
        else:
            subarr.folded = False

        # Check that if we&#39;re declaring that the input data is folded, it
        # actually is, and the mask reflects this.
        if data_folded:
            total_samples = numpy.sum(subarr.sample_sizes)
            total_per_entry = subarr._total_per_entry()
            # Which entries are nonsense in the folded fs.
            where_folded_out = total_per_entry &gt; int(total_samples/2)
            if check_folding\
               and not numpy.all(subarr.data[where_folded_out] == 0):
                logger.warn(&#39;Creating Spectrum with data_folded = True, but &#39;
                            &#39;data has non-zero values in entries which are &#39;
                            &#39;nonsensical for a folded Spectrum.&#39;)
            if check_folding\
               and not numpy.all(subarr.mask[where_folded_out]):
                logger.warn(&#39;Creating Spectrum with data_folded = True, but &#39;
                            &#39;mask is not True for all entries which are &#39;
                            &#39;nonsensical for a folded Spectrum.&#39;)

        if hasattr(data, &#39;pop_ids&#39;):
            if pop_ids is None or pop_ids == data.pop_ids:
                subarr.pop_ids = data.pop_ids
            elif pop_ids != data.pop_ids:
                logger.warn(&#39;Changing population labels in construction of new &#39;
                            &#39;Spectrum.&#39;)
                if len(pop_ids) != subarr.ndim:
                    raise ValueError(&#39;pop_ids must be of length equal to &#39;
                                     &#39;dimensionality of Spectrum.&#39;)
                subarr.pop_ids = pop_ids
        else:
            if pop_ids is not None and len(pop_ids) != subarr.ndim:
                raise ValueError(&#39;pop_ids must be of length equal to &#39;
                                 &#39;dimensionality of Spectrum.&#39;)
            subarr.pop_ids = pop_ids

        if mask_corners:
            subarr.mask_corners()

        subarr.extrap_x = extrap_x

        return subarr

    # See http://www.scipy.org/Subclasses for information on the
    # __array_finalize__ and __array_wrap__ methods. I had to do some debugging
    # myself to discover that I also needed _update_from.
    # Also, see http://docs.scipy.org/doc/numpy/reference/arrays.classes.html
    # Also, see http://docs.scipy.org/doc/numpy/user/basics.subclassing.html
    #
    # We need these methods to ensure extra attributes get copied along when
    # we do arithmetic on the FS.
    def __array_finalize__(self, obj):
        if obj is None: 
            return
        numpy.ma.masked_array.__array_finalize__(self, obj)
        self.folded = getattr(obj, &#39;folded&#39;, &#39;unspecified&#39;)
        self.pop_ids = getattr(obj, &#39;pop_ids&#39;, None)
        self.extrap_x = getattr(obj, &#39;extrap_x&#39;, None)
    def __array_wrap__(self, obj, context=None):
        result = obj.view(type(self))
        result = numpy.ma.masked_array.__array_wrap__(self, obj, 
                                                      context=context)
        result.folded = self.folded
        result.pop_ids = self.pop_ids
        result.extrap_x = self.extrap_x
        return result
    def _update_from(self, obj):
        numpy.ma.masked_array._update_from(self, obj)
        if hasattr(obj, &#39;folded&#39;):
            self.folded = obj.folded
        if hasattr(obj, &#39;pop_ids&#39;):
            self.pop_ids = obj.pop_ids
        if hasattr(obj, &#39;extrap_x&#39;):
            self.extrap_x = obj.extrap_x
    # masked_array has priority 15.
    __array_priority__ = 20

    def __repr__(self):
        return &#39;Spectrum(%s, folded=%s, pop_ids=%s)&#39;\
                % (str(self), str(self.folded), str(self.pop_ids))

    def mask_corners(self):
        &#34;&#34;&#34;
        Mask the &#39;seen in 0 samples&#39; and &#39;seen in all samples&#39; entries.
        &#34;&#34;&#34;
        self.mask.flat[0] = self.mask.flat[-1] = True

    def unmask_all(self):
        &#34;&#34;&#34;
        Unmask all values.
        &#34;&#34;&#34;
        self.mask[[slice(None)]*self.Npop] = False

    def _get_sample_sizes(self):
        return numpy.asarray(self.shape) - 1
    sample_sizes = property(_get_sample_sizes)

    def _get_Npop(self):
        return self.ndim
    Npop = property(_get_Npop)

    def _ensure_dimension(self, Npop):
        &#34;&#34;&#34;
        Ensure that fs has Npop dimensions.
        &#34;&#34;&#34;
        if not self.Npop == Npop:
            raise ValueError(&#39;Only compatible with %id spectra.&#39; % Npop)

    # Make from_file a static method, so we can use it without an instance.
    @staticmethod
    def from_file(fname, mask_corners=True, return_comments=False):
        &#34;&#34;&#34;
        Read frequency spectrum from file.

        fname: String with file name to read from. If it ends in .gz, gzip
               compression is assumed.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_comments: If true, the return value is (fs, comments), where
                         comments is a list of strings containing the comments
                         from the file (without #&#39;s).

        See to_file method for details on the file format.
        &#34;&#34;&#34;
        if fname.endswith(&#39;.gz&#39;):
            fid = gzip.open(fname, &#39;rb&#39;)
        else:
            fid = open(fname, &#39;r&#39;)

        line = fid.readline()
        # Strip out the comments
        comments = []
        while line.startswith(&#39;#&#39;):
            comments.append(line[1:].strip())
            line = fid.readline()

        # Read the shape of the data
        shape_spl = line.split()
        if &#39;folded&#39; not in shape_spl and &#39;unfolded&#39; not in shape_spl:
            # This case handles the old file format
            shape = tuple([int(d) for d in shape_spl])
            folded = False
            pop_ids = None
        else:
            # This case handles the new file format
            shape,next_ii = [int(shape_spl[0])], 1
            while shape_spl[next_ii] not in [&#39;folded&#39;, &#39;unfolded&#39;]:
                shape.append(int(shape_spl[next_ii]))
                next_ii += 1
            folded = (shape_spl[next_ii] == &#39;folded&#39;)
            # Are there population labels in the file?
            if len(shape_spl) &gt; next_ii + 1:
                pop_ids = line.split(&#39;&#34;&#39;)[1::2]
            else:
                pop_ids = None

        data = numpy.fromstring(fid.readline().strip(), 
                                count=numpy.product(shape), sep=&#39; &#39;)
        # fromfile returns a 1-d array. Reshape it to the proper form.
        data = data.reshape(*shape)

        maskline = fid.readline().strip()
        if not maskline:
            # The old file format didn&#39;t have a line for the mask
            mask = None
        else:
            # This case handles the new file format
            mask = numpy.fromstring(maskline, 
                                    count=numpy.product(shape), sep=&#39; &#39;)
            mask = mask.reshape(*shape)

        fs = Spectrum(data, mask, mask_corners, data_folded=folded,
                      pop_ids=pop_ids)

        fid.close()
        if not return_comments:
            return fs
        else:
            return fs,comments

    fromfile = from_file

    def to_file(self, fname, precision=16, comment_lines = [], 
                foldmaskinfo=True):
        &#34;&#34;&#34;
        Write frequency spectrum to file.

        fname: File name to write to.  If string ends in .gz, file will be saved
               with gzip compression.
        precision: precision with which to write out entries of the SFS. (They
                   are formated via %.&lt;p&gt;g, where &lt;p&gt; is the precision.)
        comment lines: list of strings to be used as comment lines in the header
                       of the output file.
        foldmaskinfo: If False, folding and mask and population label
                      information will not be saved. This conforms to the file
                      format for dadi versions prior to 1.3.0.

        The file format is:
            # Any number of comment lines beginning with a &#39;#&#39;
            A single line containing N integers giving the dimensions of the fs
              array. So this line would be &#39;5 5 3&#39; for an SFS that was 5x5x3.
              (That would be 4x4x2 *samples*.)
            On the *same line*, the string &#39;folded&#39; or &#39;unfolded&#39; denoting the
              folding status of the array
            On the *same line*, optional strings each containing the population
              labels in quotes separated by spaces, e.g. &#34;pop 1&#34; &#34;pop 2&#34;
            A single line giving the array elements. The order of elements is 
              e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] ... fs[0,1,0] fs[0,1,1] ...
            A single line giving the elements of the mask in the same order as
              the data line. &#39;1&#39; indicates masked, &#39;0&#39; indicates unmasked.
        &#34;&#34;&#34;
        # Open the file object.
        if fname.endswith(&#39;.gz&#39;):
            fid = gzip.open(fname, &#39;wb&#39;)
        else:
            fid = open(fname, &#39;w&#39;)

        # Write comments
        for line in comment_lines:
            fid.write(&#39;# &#39;)
            fid.write(line.strip())
            fid.write(&#39;\n&#39;)

        # Write out the shape of the fs
        for elem in self.data.shape:
            fid.write(&#39;%i &#39; % elem)

        if foldmaskinfo:
            if not self.folded:
                fid.write(&#39;unfolded&#39;)
            else:
                fid.write(&#39;folded&#39;)
            if self.pop_ids is not None:
                for label in self.pop_ids:
                    fid.write(&#39; &#34;%s&#34;&#39; % label)

        fid.write(&#39;\n&#39;)

        # Write the data to the file. The obnoxious ravel call is to
        # ensure compatibility with old version that used self.data.tofile.
        numpy.savetxt(fid, [self.data.ravel()], delimiter=&#39; &#39;,
                      fmt=&#39;%%.%ig&#39; % precision)

        if foldmaskinfo:
            # Write the mask to the file
            numpy.savetxt(fid, [numpy.asarray(self.mask, int).ravel()],
                          delimiter=&#39; &#39;, fmt=&#39;%d&#39;)

        fid.close()

    tofile = to_file

    ## Overide the (perhaps confusing) original numpy tofile method.
    #def tofile(self, *args,**kwargs):
    #    self.to_file(*args, **kwargs)

    def project(self, ns):
        &#34;&#34;&#34;
        Project to smaller sample size.

        ns: Sample sizes for new spectrum.
        &#34;&#34;&#34;
        if len(ns) != self.Npop:
            raise ValueError(&#39;Requested sample sizes not of same dimension &#39;
                             &#39;as spectrum. Perhaps you need to marginalize &#39;
                             &#39;over some populations first?&#39;)
        if numpy.any(numpy.asarray(ns) &gt; numpy.asarray(self.sample_sizes)):
            raise ValueError(&#39;Cannot project to a sample size greater than &#39;
                             &#39;original. Original size is %s and requested size &#39;
                             &#39;is %s.&#39; % (self.sample_sizes, ns))

        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # projecting.
        if original_folded:
            output = self.unfold()
        else:
            output = self.copy()

        # Iterate over each axis, applying the projection.
        for axis,proj in enumerate(ns):
            if proj != self.sample_sizes[axis]:
                output = output._project_one_axis(proj, axis)

        output.pop_ids = self.pop_ids
        output.extrap_x = self.extrap_x

        # Return folded or unfolded as original.
        if original_folded:
            return output.fold()
        else:
            return output

    def _project_one_axis(self, n, axis=0):
        &#34;&#34;&#34;
        Project along a single axis.
        &#34;&#34;&#34;
        # This gets a little tricky with fancy indexing to make it work
        # for fs with arbitrary number of dimensions.
        if n &gt; self.sample_sizes[axis]:
            raise ValueError(&#39;Cannot project to a sample size greater than &#39;
                             &#39;original. Called sizes were from %s to %s.&#39; 
                             % (self.sample_sizes[axis], n))

        newshape = list(self.shape)
        newshape[axis] = n+1
        # Create a new empty fs that we&#39;ll fill in below.
        pfs = Spectrum(numpy.zeros(newshape), mask_corners=False)

        # Set up for our fancy indexes. These slices are currently like
        # [:,:,...]
        from_slice = [slice(None) for ii in range(self.Npop)]
        to_slice = [slice(None) for ii in range(self.Npop)]
        proj_slice = [nuax for ii in range(self.Npop)]

        proj_from = self.sample_sizes[axis]
        # For each possible number of hits.
        for hits in range(proj_from+1):
            # Adjust the slice in the array we&#39;re projecting from.
            from_slice[axis] = slice(hits, hits+1)
            # These are the least and most possible hits we could have in the
            #  projected fs.
            least, most = max(n - (proj_from - hits), 0), min(hits,n)
            to_slice[axis] = slice(least, most+1)
            # The projection weights.
            proj = _cached_projection(n, proj_from, hits)
            proj_slice[axis] = slice(least, most+1)
            # Do the multiplications
            pfs.data[tuple(to_slice)] += self.data[tuple(from_slice)] * proj[tuple(proj_slice)]
            pfs.mask[tuple(to_slice)] = numpy.logical_or(pfs.mask[tuple(to_slice)],
                                                         self.mask[tuple(from_slice)])

        return pfs

    def marginalize(self, over, mask_corners=True):
        &#34;&#34;&#34;
        Reduced dimensionality spectrum summing over some populations.

        over: sequence of axes to sum over. For example (0,2) will sum over
              populations 0 and 2.
        mask_corners: If True, the typical corners of the resulting fs will be
                      masked
        &#34;&#34;&#34;
        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # marginalizing.
        if original_folded:
            output = self.unfold()
        else:
            output = self.copy()

        orig_mask = output.mask.copy()
        orig_mask.flat[0] = orig_mask.flat[-1] = False
        if numpy.any(orig_mask):
            logger.warn(&#39;Marginalizing a Spectrum with internal masked values. &#39;
                        &#39;This may not be a well-defined operation.&#39;)

        # Do the marginalization
        for axis in sorted(over)[::-1]:
            output = output.sum(axis=axis)
        pop_ids = None
        if self.pop_ids is not None:
            pop_ids = list(self.pop_ids)
            for axis in sorted(over)[::-1]:
                del pop_ids[axis]
        output.folded = False
        output.pop_ids = pop_ids
        output.extrap_x = self.extrap_x

        if mask_corners:
            output.mask_corners()

        # Return folded or unfolded as original.
        if original_folded:
            return output.fold()
        else:
            return output

    def filter_pops(self, tokeep, mask_corners=True):
        &#34;&#34;&#34;
        Filter Spectrum to keep only certain populations.

        Returns new Spectrum with len(tokeep) populations.
        Note: This is similar in practice to the marginalize operation. But here
              populations are numbered from 1, as in the majority of dadi.

        tokeep: List of population numbers to keep, numbering from 1.
        mask_corners: If True, the typical corners of the resulting fs will be
                      masked
        &#34;&#34;&#34;
        toremove = list(range(0, self.ndim))
        for pop_ii in tokeep:
            # Apply -1 factor to account for indexing in marginalize
            toremove.remove(pop_ii-1)
        return self.marginalize(toremove)

    def _counts_per_entry(self):
        &#34;&#34;&#34;
        Counts per population for each entry in the fs.
        &#34;&#34;&#34;
        ind = numpy.indices(self.shape)
        # Transpose the first access to the last, so ind[ii,jj,kk] = [ii,jj,kk]
        ind = ind.transpose(list(range(1,self.Npop+1))+[0])
        return ind

    def _total_per_entry(self):
        &#34;&#34;&#34;
        Total derived alleles for each entry in the fs.
        &#34;&#34;&#34;
        return numpy.sum(self._counts_per_entry(), axis=-1)

    def log(self):
        &#34;&#34;&#34;
        Return the natural logarithm of the entries of the frequency spectrum.

        Only necessary because numpy.ma.log now fails to propagate extra
        attributes after numpy 1.10.
        &#34;&#34;&#34;
        logfs = numpy.ma.log(self)
        logfs.folded = self.folded
        logfs.pop_ids = self.pop_ids
        logfs.extrap_x = self.extrap_x
        return logfs

    def fold(self):
        &#34;&#34;&#34;
        Folded frequency spectrum
    
        The folded fs assumes that information on which allele is ancestral or
        derived is unavailable. Thus the fs is in terms of minor allele 
        frequency.  Note that this makes the fs into a &#34;triangular&#34; array.
    
        Note that if a masked cell is folded into non-masked cell, the
        destination cell is masked as well.

        Note also that folding is not done in-place. The return value is a new
        Spectrum object.
        &#34;&#34;&#34;
        if self.folded:
            raise ValueError(&#39;Input Spectrum is already folded.&#39;)

        # How many samples total do we have? The folded fs can only contain
        # entries up to total_samples/2 (rounded down).
        total_samples = numpy.sum(self.sample_sizes)

        total_per_entry = self._total_per_entry()
    
        # Here&#39;s where we calculate which entries are nonsense in the folded fs.
        where_folded_out = total_per_entry &gt; int(total_samples/2)
    
        original_mask = self.mask
        # Here we create a mask that masks any values that were masked in
        # the original fs (or folded onto by a masked value).
        final_mask = numpy.logical_or(original_mask, 
                                      reverse_array(original_mask))
        
        # To do the actual folding, we take those entries that would be folded
        # out, reverse the array along all axes, and add them back to the
        # original fs.
        reversed = reverse_array(numpy.where(where_folded_out, self, 0))
        folded = numpy.ma.masked_array(self.data + reversed)
        folded.data[where_folded_out] = 0
    
        # Deal with those entries where assignment of the minor allele is
        # ambiguous.
        where_ambiguous = (total_per_entry == total_samples/2.)
        ambiguous = numpy.where(where_ambiguous, self, 0)
        folded += -0.5*ambiguous + 0.5*reverse_array(ambiguous)
    
        # Mask out the remains of the folding operation.
        final_mask = numpy.logical_or(final_mask, where_folded_out)

        outfs = Spectrum(folded, mask=final_mask, data_folded=True,
                         pop_ids=self.pop_ids)
        outfs.extrap_x = self.extrap_x
        return outfs

    def unfold(self):
        &#34;&#34;&#34;
        Unfolded frequency spectrum
    
        It is assumed that each state of a SNP is equally likely to be
        ancestral.

        Note also that unfolding is not done in-place. The return value is a new
        Spectrum object.
        &#34;&#34;&#34;
        if not self.folded:
            raise ValueError(&#39;Input Spectrum is not folded.&#39;)

        # Unfolding the data is easy.
        reversed_data = reverse_array(self.data)
        newdata = (self.data + reversed_data)/2.

        # Unfolding the mask is trickier. We want to preserve masking of entries
        # that were masked in the original Spectrum.
        # Which entries in the original Spectrum were masked solely because
        # they are incompatible with a folded Spectrum?
        total_samples = numpy.sum(self.sample_sizes)
        total_per_entry = self._total_per_entry()
        where_folded_out = total_per_entry &gt; int(total_samples/2)

        newmask = numpy.logical_xor(self.mask, where_folded_out)
        newmask = numpy.logical_or(newmask, reverse_array(newmask))
    
        outfs = Spectrum(newdata, mask=newmask, data_folded=False, 
                         pop_ids=self.pop_ids)
        outfs.extrap_x = self.extrap_x
        return outfs

    def fixed_size_sample(self, nsamples, only_nonmasked=False):
        &#34;&#34;&#34;
        Generate a resampled fs from the current one.

        nsamples: Number of samples to include in the new FS.
        only_nonmasked: If True, only SNPs from non-masked will be resampled. 
                        Otherwise, all SNPs will be used.
        &#34;&#34;&#34;
        flat = self.flatten()
        if only_nonmasked:
            pvals = flat.data/flat.sum()
            pvals[flat.mask] = 0
        else:
            pvals = flat.data/flat.data.sum()
    
        sample = numpy.random.multinomial(int(nsamples), pvals)
        sample = sample.reshape(self.shape)
    
        return dadi.Spectrum(sample, mask=self.mask, pop_ids=self.pop_ids)

    def sample(self):
        &#34;&#34;&#34;
        Generate a Poisson-sampled fs from the current one.

        Note: Entries where the current fs is masked will be masked in the
              output sampled fs.
        &#34;&#34;&#34;
        import scipy.stats
        # These are entries where the sampling has no meaning, b/c fs is masked.
        bad_entries = self.mask
        # We convert to a 1-d array for passing into the sampler
        means = self.ravel().copy()
        # Filter out those bad entries.
        means[bad_entries.ravel()] = 1
        # Sample
        samp = scipy.stats.distributions.poisson.rvs(means, size=len(means))
        # Replace bad entries with zero
        samp[bad_entries.ravel()] = 0
        # Convert back to a properly shaped array
        samp = samp.reshape(self.shape)
        # Convert to a fs and mask the bad entries
        samp = Spectrum(samp, mask=self.mask, data_folded=self.folded,
                        pop_ids = self.pop_ids)
        return samp

    @staticmethod
    def from_ms_file(fid, average=True, mask_corners=True, return_header=False,
                     pop_assignments=None, pop_ids=None, bootstrap_segments=1):
        &#34;&#34;&#34;
        Read frequency spectrum from file of ms output.

        fid: string with file name to read from or an open file object.
        average: If True, the returned fs is the average over the runs in the ms
                 file. If False, the returned fs is the sum.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_header: If True, the return value is (fs, (command,seeds), where
                       command and seeds are strings containing the ms
                       commandline and the seeds used.
        pop_assignments: If None, the assignments of samples to populations is
                         done automatically, using the assignment in the ms
                         command line. To manually assign populations, pass a
                         list of the from [6,8]. This example places
                         the first 6 samples into population 1, and the next 8
                         into population 2.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        bootstrap_segments: If bootstrap_segments is an integer greater than 1,
                            the data will be broken up into that many segments
                            based on SNP position. Instead of single FS, a list
                            of spectra will be returned, one for each segment.
        &#34;&#34;&#34;
        newfile = False
        # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
        # use to open a file.
        if not hasattr(fid, &#39;read&#39;):
            newfile = True
            fid = open(fid, &#39;r&#39;)

        # Parse the commandline
        command = line = fid.readline()
        command_terms = line.split()
        
        if command_terms[0].count(&#39;ms&#39;):
            runs = int(command_terms[2])
            try:
                pop_flag = command_terms.index(&#39;-I&#39;)
                num_pops = int(command_terms[pop_flag+1])
                pop_samples = [int(command_terms[pop_flag+ii])
                               for ii in range(2, 2+num_pops)]
            except ValueError:
                num_pops = 1
                pop_samples = [int(command_terms[1])]
        else:
            raise ValueError(&#39;Unrecognized command string: %s.&#39; % command)
        
        total_samples = numpy.sum(pop_samples)
        if pop_assignments:
            num_pops = len(pop_assignments)
            pop_samples = pop_assignments

        sample_indices = numpy.cumsum([0] + pop_samples)
        bottom_l = sample_indices[:-1]
        top_l = sample_indices[1:]
        
        seeds = line = fid.readline()
        while not line.startswith(&#39;//&#39;):
            line = fid.readline()
        
        counts = numpy.zeros(len(pop_samples), numpy.int_)
        fs_shape = numpy.asarray(pop_samples) + 1
        dimension = len(counts)
        
        if dimension &gt; 1:
            bottom0 = bottom_l[0]
            top0 = top_l[0]
            bottom1 = bottom_l[1]
            top1 = top_l[1]
        if dimension &gt; 2:
            bottom2 = bottom_l[2]
            top2 = top_l[2]
        if dimension &gt; 3:
            bottom3 = bottom_l[3]
            top3 = top_l[3]
        if dimension &gt; 4:
            bottom4 = bottom_l[4]
            top4 = top_l[4]
        if dimension &gt; 5:
            bottom5 = bottom_l[5]
            top5 = top_l[5]
        
        all_data = [numpy.zeros(fs_shape, numpy.int_)
                    for boot_ii in range(bootstrap_segments)]
        for run_ii in range(runs):
            line = fid.readline()
            segsites = int(line.split()[-1])
            
            if segsites == 0:
                # Special case, need to read 3 lines to stay synced.
                for _ in range(3):
                    line = fid.readline()
                continue
            line = fid.readline()
            while not line.startswith(&#39;positions&#39;):
                line = fid.readline()

            # Read SNP positions for creating bootstrap segments
            positions = [float(_) for _ in line.split()[1:]]
            # Where we should break our interval to create our bootstraps
            breakpts = numpy.linspace(0, 1, bootstrap_segments+1)
            # The indices that correspond to those breakpoints
            break_iis = numpy.searchsorted(positions, breakpts)
            # Correct for searchsorted behavior if last position is 1,
            # to ensure all SNPs are captured
            break_iis[-1] = len(positions)
        
            # Read the chromosomes in
            chromos = fid.read((segsites+1)*total_samples)
        
            # For each bootstrap segment, relevant SNPs run from start_ii:end_ii
            for boot_ii, (start_ii, end_ii) \
                    in enumerate(zip(break_iis[:-1], break_iis[1:])):
                # Use the data array corresponding to this bootstrap segment
                data = all_data[boot_ii]
                for snp in range(start_ii, end_ii):
                    # Slice to get all the entries that refer to a given SNP
                    this_snp = chromos[snp::segsites+1]
                    # Count SNPs per population, and record them.
                    if dimension == 1:
                        data[this_snp.count(&#39;1&#39;)] += 1
                    elif dimension == 2:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;)] += 1
                    elif dimension == 3:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;)] += 1
                    elif dimension == 4:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;)] += 1
                    elif dimension == 5:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;),
                             this_snp[bottom4:top4].count(&#39;1&#39;)] += 1
                    elif dimension == 6:
                        data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                             this_snp[bottom1:top1].count(&#39;1&#39;),
                             this_snp[bottom2:top2].count(&#39;1&#39;),
                             this_snp[bottom3:top3].count(&#39;1&#39;),
                             this_snp[bottom4:top4].count(&#39;1&#39;),
                             this_snp[bottom5:top5].count(&#39;1&#39;)] += 1
                    else:
                        # This is noticably slower, so we special case the cases
                        # above.
                        for dim_ii in range(dimension):
                            bottom = bottom_l[dim_ii]
                            top = top_l[dim_ii]
                            counts[dim_ii] = this_snp[bottom:top].count(&#39;1&#39;)
                        data[tuple(counts)] += 1
        
            # Read to the next iteration
            line = fid.readline()
            line = fid.readline()

        if newfile:
            fid.close()

        all_fs = [Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
                  for data in all_data]
        if average:
            all_fs = [fs/runs for fs in all_fs]

        # If we aren&#39;t setting up for bootstrapping, return fs, rather than a
        # list of length 1. (This ensures backward compatibility.)
        if bootstrap_segments == 1:
            all_fs = all_fs[0]

        if not return_header:
            return all_fs
        else:
            return all_fs, (command,seeds)

    @staticmethod
    def from_sfscode_file(fid, sites=&#39;all&#39;, average=True, mask_corners=True, 
                          return_header=False, pop_ids=None):
        &#34;&#34;&#34;
        Read frequency spectrum from file of sfs_code output.

        fid: string with file name to read from or an open file object.
        sites: If sites==&#39;all&#39;, return the fs of all sites. If sites == &#39;syn&#39;,
               use only synonymous mutations. If sites == &#39;nonsyn&#39;, use
               only non-synonymous mutations.
        average: If True, the returned fs is the average over the runs in the 
                 file. If False, the returned fs is the sum.
        mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                      all samples&#39; entries.
        return_header: If true, the return value is (fs, (command,seeds), where
                       command and seeds are strings containing the ms
                       commandline and the seeds used.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        &#34;&#34;&#34;
        newfile = False
        # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
        # use to open a file.
        if not hasattr(fid, &#39;read&#39;):
            newfile = True
            fid = open(fid, &#39;r&#39;)

        if sites == &#39;all&#39;:
            only_nonsyn, only_syn = False, False
        elif sites == &#39;syn&#39;:
            only_nonsyn, only_syn = False, True
        elif sites == &#39;nonsyn&#39;:
            only_nonsyn, only_syn = True, False
        else:
            raise ValueError(&#34;&#39;sites&#39; argument must be one of (&#39;all&#39;, &#39;syn&#39;, &#34;
                             &#34;&#39;nonsyn&#39;).&#34;)
        
        command = fid.readline()
        command_terms = command.split()
        
        runs = int(command_terms[2])
        num_pops = int(command_terms[1])
        
        # sfs_code default is 6 individuals, and I assume diploid pop
        pop_samples = [12] *  num_pops
        if &#39;--sampSize&#39; in command_terms or &#39;-n&#39; in command_terms:
            try:
                pop_flag = command_terms.index(&#39;--sampSize&#39;)
                pop_flag = command_terms.index(&#39;-n&#39;)
            except ValueError:
                pass
            pop_samples = [2*int(command_terms[pop_flag+ii])
                           for ii in range(1, 1+num_pops)]
        
        pop_samples = numpy.asarray(pop_samples)
        pop_fixed_str = [&#39;,%s.-1&#39; % i for i in range(num_pops)]
        pop_count_str = [&#39;,%s.&#39; % i for i in range(num_pops)]
        
        seeds = fid.readline()
        line = fid.readline()
        
        data = numpy.zeros(numpy.asarray(pop_samples)+1, numpy.int_)
        
        # line = //iteration...
        line = fid.readline()
        for iter_ii in range(runs):
            for ii in range(5):
                line = fid.readline()
        
            # It is possible for a mutation to be listed several times in the
            # output.  To accomodate this, I keep a dictionary of identities
            # for those mutations, and hold off processing them until I&#39;ve seen
            # all mutations listed for the iteration.
            mut_dict = {}
            
            # Loop until this iteration ends.
            while not line.startswith(&#39;//&#39;) and line != &#39;&#39;:
                split_line = line.split(&#39;;&#39;)
                if split_line[-1] == &#39;\n&#39;:
                    split_line = split_line[:-1]
        
                # Loop over mutations on this line.
                for mut_ii, mutation in enumerate(split_line):
                    counts_this_mut = numpy.zeros(num_pops, numpy.int_)
        
                    split_mut = mutation.split(&#39;,&#39;)
        
                    # Exclude synonymous mutations
                    if only_nonsyn and split_mut[7] == &#39;0&#39;:
                        continue
                    # Exclude nonsynonymous mutations
                    if only_syn and split_mut[7] == &#39;1&#39;:
                        continue
        
                    ind_start = len(&#39;,&#39;.join(split_mut[:12]))
                    by_individual = mutation[ind_start:]
        
                    mut_id = &#39;,&#39;.join(split_mut[:4] + split_mut[5:11])
        
                    # Count mutations in each population
                    for pop_ii,fixed_str,count_str\
                            in zip(range(num_pops), pop_fixed_str, 
                                   pop_count_str):
                        if fixed_str in by_individual:
                            counts_this_mut[pop_ii] = pop_samples[pop_ii]
                        else:
                            counts_this_mut[pop_ii] =\
                                    by_individual.count(count_str)
        
                    # Initialize the list that will track the counts for this
                    # mutation. Using setdefault means that it won&#39;t overwrite
                    # if there&#39;s already a list stored there.
                    mut_dict.setdefault(mut_id, [0]*num_pops)
                    for ii in range(num_pops):
                        if counts_this_mut[ii] &gt; 0 and mut_dict[mut_id][ii] &gt; 0:
                            sys.stderr.write(&#39;Contradicting counts between &#39;
                                             &#39;listings for mutation %s in &#39;
                                             &#39;population %i.&#39; 
                                             % (mut_id, ii))
                        mut_dict[mut_id][ii] = max(counts_this_mut[ii], 
                                                   mut_dict[mut_id][ii])
        
                line = fid.readline()
        
            # Now apply all the mutations with fixations that we deffered.
            for mut_id, counts in mut_dict.items():
                if numpy.any(numpy.asarray(counts) &gt; pop_samples):
                    sys.stderr.write(&#39;counts_this_mut &gt; pop_samples: %s &gt; &#39;
                                     &#39;%s\n%s\n&#39; % (counts, pop_samples, mut_id))
                    counts = numpy.minimum(counts, pop_samples)
                data[tuple(counts)] += 1
        
        if newfile:
            fid.close()
        
        fs = Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
        if average:
            fs /= runs

        if not return_header:
            return fs
        else:
            return fs, (command,seeds)

    def Fst(self):
        &#34;&#34;&#34;
        Wright&#39;s Fst between the populations represented in the fs.
    
        This estimate of Fst assumes random mating, because we don&#39;t have
        heterozygote frequencies in the fs.
    
        Calculation is by the method of Weir and Cockerham _Evolution_ 38:1358
        (1984).  For a single SNP, the relevant formula is at the top of page
        1363. To combine results between SNPs, we use the weighted average
        indicated by equation 10.
        &#34;&#34;&#34;
        # This gets a little obscure because we want to be able to work with
        # spectra of arbitrary dimension.
    
        # First quantities from page 1360
        r = self.Npop
        ns = self.sample_sizes
        nbar = numpy.mean(ns)
        nsum = numpy.sum(ns)
        nc = (nsum - numpy.sum(ns**2)/nsum)/(r-1)
    
        # counts_per_pop is an r+1 dimensional array, where the last axis simply
        # records the indices of the entry. 
        # For example, counts_per_pop[4,19,8] = [4,19,8]
        counts_per_pop = numpy.indices(self.shape)
        counts_per_pop = numpy.transpose(counts_per_pop, axes=list(range(1,r+1))+[0])
    
        # The last axis of ptwiddle is now the relative frequency of SNPs in
        # that bin in each of the populations.
        ptwiddle = 1.*counts_per_pop/ns
    
        # Note that pbar is of the same shape as fs...
        pbar = numpy.sum(ns*ptwiddle, axis=-1)/nsum
    
        # We need to use &#39;this_slice&#39; to get the proper aligment between
        # ptwiddle and pbar.
        this_slice = [slice(None)]*r + [numpy.newaxis]
        s2 = numpy.sum(ns * (ptwiddle - pbar[tuple(this_slice)])**2, axis=-1)/((r-1)*nbar)
    
        # Note that this &#39;a&#39; differs from equation 2, because we&#39;ve used
        # equation 3 and b = 0 to solve for hbar.
        a = nbar/nc * (s2 - 1/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2))
        d = 2*nbar/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2)
    
        # The weighted sum over loci.
        asum = (self * a).sum()
        dsum = (self * d).sum()
    
        return asum/(asum+dsum)

    def S(self):
        &#34;&#34;&#34;
        Segregating sites.
        &#34;&#34;&#34;
        oldmask = self.mask.copy()
        self.mask_corners()
        S = self.sum()
        self.mask = oldmask
        return S
    
    def Watterson_theta(self):
        &#34;&#34;&#34;
        Watterson&#39;s estimator of theta.
    
        Note that is only sensible for 1-dimensional spectra.
        &#34;&#34;&#34;
        if self.Npop != 1:
            raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)
    
        n = self.sample_sizes[0]
        S = self.S()
        an = numpy.sum(1./numpy.arange(1,n))
    
        return S/an
    
    def theta_L(self):
        &#34;&#34;&#34;
        theta_L as defined by Zeng et al. &#34;Statistical Tests for Detecting
        Positive Selection by Utilizing High-Frequency Variants&#34; (2006)
        Genetics
    
        Note that is only sensible for 1-dimensional spectra.
        &#34;&#34;&#34;
        if self.Npop != 1:
            raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)
    
        n = self.sample_sizes[0]
        return numpy.sum(numpy.arange(1,n)*self[1:n])/(n-1)

    def Zengs_E(self):
        &#34;&#34;&#34;
        Zeng et al.&#39;s E statistic.

        From Zeng et al. &#34;Statistical Tests for Detecting Positive Selection by
        Utilizing High-Frequency Variants&#34; (2006) Genetics
        &#34;&#34;&#34;
        num = self.theta_L() - self.Watterson_theta()

        n = self.sample_sizes[0]

        # See after Eq. 3
        an = numpy.sum(1./numpy.arange(1,n))
        # See after Eq. 9
        bn = numpy.sum(1./numpy.arange(1,n)**2)
        s = self.S()

        # See immediately after Eq. 12
        theta = self.Watterson_theta()
        theta_sq = s*(s-1.)/(an**2 + bn)

        # Eq. 14
        var = (n/(2.*(n-1.)) - 1./an) * theta\
                + (bn/an**2 + 2.*(n/(n-1.))**2 * bn - 2*(n*bn-n+1.)/((n-1.)*an)
                   - (3.*n+1.)/(n-1.)) * theta_sq

        return num/numpy.sqrt(var)
    
    def pi(self):
        r&#34;&#34;&#34;
        Estimated expected number of pairwise differences between two
        chromosomes in the population.
    
        Note that this estimate includes a factor of sample_size/(sample_size-1)
        to make E(\hat{pi}) = theta.
        &#34;&#34;&#34;
        if self.ndim != 1:
            raise ValueError(&#34;Only defined for a one-dimensional SFS.&#34;)
    
        n = self.sample_sizes[0]
        # sample frequencies p 
        p = numpy.arange(0,n+1,dtype=float)/n
        # This expression derives from Gillespie&#39;s _Population_Genetics:_A
        # _Concise_Guide_, 2nd edition, section 2.6.
        return n/(n-1.) * 2*numpy.ma.sum(self*p*(1-p))
    
    def Tajima_D(self):
        &#34;&#34;&#34;
        Tajima&#39;s D.
    
        Following Gillespie &#34;Population Genetics: A Concise Guide&#34; pg. 45
        &#34;&#34;&#34;
        if not self.Npop == 1:
            raise ValueError(&#34;Only defined on a one-dimensional SFS.&#34;)
    
        S = self.S()
    
        n = 1.*self.sample_sizes[0]
        pihat = self.pi()
        theta = self.Watterson_theta()
    
        a1 = numpy.sum(1./numpy.arange(1,n))
        a2 = numpy.sum(1./numpy.arange(1,n)**2)
        b1 = (n+1)/(3*(n-1))
        b2 = 2*(n**2 + n + 3)/(9*n * (n-1))
        c1 = b1 - 1./a1
        c2 = b2 - (n+2)/(a1*n) + a2/a1**2
    
        C = numpy.sqrt((c1/a1)*S + c2/(a1**2 + a2) * S*(S-1))
    
        return (pihat - theta)/C

    @staticmethod
    def _from_phi_1D_direct(n, xx, phi, mask_corners=True,
                            het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros(n+1)
        for ii in range(0,n+1):
            factorx = comb(n,ii) * xx**ii * (1-xx)**(n-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            data[ii] = trapz(factorx * phi, xx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_1D_direct_inbreeding(n, xx, phi, Fx, mask_corners=True,
                                       ploidyx=2,het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        if n % ploidyx == 0:
            nInd = n/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1}.&#39;.format(str(n),str(ploidyx)))
        data = numpy.zeros(n+1)
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax  = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        for ii in range(0,n+1):
            factorx = [BetaBinomConvolution(ii,nInd,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))]
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            data[ii] = trapz(factorx*phi,xx)
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_1D_analytic(n, xx, phi, mask_corners=True, 
                              divergent=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        divergent: If True, the interval from xx[0] to xx[1] is modeled as
                   phi[1] * xx[1]/x. This captures the typical 1/x
                   divergence at x = 0.
        &#34;&#34;&#34;
        # This function uses the result that 
        # \int_0^y \Gamma(a+b)/\Gamma(a) \Gamma(b) x^{a-1) (1-x)^{b-1} 
        # is betainc(a,b,y)
        # So the integral in analytic for a piece-wise linear phi.
        data = numpy.zeros(n+1)

        # Values for xx just slighly (~1e-16) outside the range [0,1] can cause
        # betainc calculation to fail.
        xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)

        # Slopes of our linear-segments
        s = (phi[1:]-phi[:-1])/(xx[1:]-xx[:-1])
        # For the integration of the &#34;constant&#34; term in the piecewise linear
        # approximation of phi from each interval to the next.
        c1 = (phi[:-1] - s*xx[:-1])/(n+1)
        for d in range(0,n+1):
            c2 = s*(d+1)/((n+1)*(n+2))
            beta1 = betainc(d+1,n-d+1,xx)
            beta2 = betainc(d+2,n-d+1,xx)
            # Each entry is the value of the integral from one value of xx to
            # the next.
            entries = c1*(beta1[1:]-beta1[:-1]) + c2*(beta2[1:]-beta2[:-1])
            if divergent:
                entries[0] = phi[1]*xx[1]/d * betainc(d,n-d+1,xx[1])
            data[d] = numpy.sum(entries)
        fs = dadi.Spectrum(data, mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_phi_2D_direct(nx, ny, xx, yy, phi, mask_corners=True, 
                            het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        data = numpy.zeros((nx+1, ny+1))

        # Cache to avoid duplicated work.
        factorx_cache = {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx

        dx, dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            integrated_over_y = trapz(factory[numpy.newaxis,:]*phi, dx=dy)
            for ii in range(0, nx+1):
                factorx = factorx_cache[nx,ii]
                data[ii,jj] = trapz(factorx*integrated_over_y, dx=dx)

        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_2D_direct_inbreeding(nx, ny, xx, yy, phi, Fx, Fy, mask_corners=True,
                                       ploidyx=2,ploidyy=2,het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi plus
        inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        if nx % ploidyx == 0:
            nIndx = nx/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 1.&#39;.format(str(nx),str(ploidyx)))
        
        if ny % ploidyy == 0:
            nIndy = ny/ploidyy
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 2.&#39;.format(str(ny),str(ploidyy)))
        
        data = numpy.zeros((nx+1, ny+1))
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        alphay = yy*((1.0-Fy)/Fy)
        alphay[0],alphay[-1] = 1.0e-20*((1.0-Fy)/Fy), (1.0-1.0e-20)*((1.0-Fy)/Fy)
        betay = (1.0-yy)*((1.0-Fy)/Fy)
        betay[0],betay[-1] = (1.0-1.0e-20)*((1.0-Fy)/Fy), 1.0e-20*((1.0-Fy)/Fy)
        # Cache to avoid duplicated work
        factorx_cache = {}
        for ii in range(0,nx+1):
            factorx = numpy.array([BetaBinomConvolution(ii,nIndx,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))])
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        
        dx,dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = numpy.array([BetaBinomConvolution(jj,nIndy,alphay[j],betay[j],ploidy=ploidyy) for j in range(0,len(yy))])
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            integrated_over_y = trapz(factory[numpy.newaxis,:]*phi, dx=dy)
            for ii in range(0,nx+1):
                factorx = factorx_cache[nx,ii]
                data[ii,jj] = trapz(factorx*integrated_over_y, dx=dx)
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_2D_admix_props(nx, ny, xx, yy, phi, mask_corners=True, 
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        xadmix = admix_props[0][0]*xx[:,nuax] + admix_props[0][1]*yy[nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax] + admix_props[1][1]*yy[nuax,:]

        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        data = numpy.zeros((nx+1, ny+1))
        
        # Cache to avoid duplicated work.
        factorx_cache = {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx
    
        dx, dy = numpy.diff(xx), numpy.diff(yy)
        for jj in range(0,ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            for ii in range(0, nx+1):
                integrated_over_y = trapz(factorx_cache[nx,ii] * factory * phi,
                                          dx=dy)
                data[ii,jj] = trapz(integrated_over_y, dx=dx)
    
        fs = Spectrum(data, mask_corners=mask_corners)
        fs.extrap_x = xx[1]
        return fs

    #@staticmethod
    #def _from_phi_2D_analytic(nx, ny, xx, yy, phi, mask_corners=True):
    #    &#34;&#34;&#34;
    #    Compute sample Spectrum from population frequency distribution phi.

    #    This function uses analytic formulae for integrating over a 
    #    piecewise-linear approximation to phi.

    #    See from_phi for explanation of arguments.
    #    &#34;&#34;&#34;
    #    data = numpy.zeros((nx+1,ny+1))

    #    xx = numpy.minimum(numpy.maximum(xx, 0), 1.0)
    #    yy = numpy.minimum(numpy.maximum(yy, 0), 1.0)

    #    beta_cache_xx = {}
    #    for ii in range(0, nx+1):
    #        beta_cache_xx[ii+1,nx-ii+1] = betainc(ii+1,nx-ii+1,xx)
    #        beta_cache_xx[ii+2,nx-ii+1] = betainc(ii+2,nx-ii+1,xx)

    #    s_yy = (phi[:,1:]-phi[:,:-1])/(yy[nuax,1:]-yy[nuax,:-1])
    #    c1_yy = (phi[:,:-1] - s_yy*yy[nuax,:-1])/(ny+1)
    #    for jj in range(0, ny+1):
    #        c2_yy = s_yy*(jj+1)/((ny+1)*(ny+2))
    #        beta1_yy = betainc(jj+1,ny-jj+1,yy)
    #        beta2_yy = betainc(jj+2,ny-jj+1,yy)
    #        over_y = numpy.sum(c1_yy*(beta1_yy[nuax,1:]-beta1_yy[nuax,:-1])
    #                           + c2_yy*(beta2_yy[nuax,1:]-beta2_yy[nuax,:-1]),
    #                           axis=-1)

    #        s_xx = (over_y[1:]-over_y[:-1])/(xx[1:]-xx[:-1])
    #        c1_xx = (over_y[:-1] - s_xx*xx[:-1])/(nx+1)
    #        for ii in range(0, nx+1):
    #            c2_xx = s_xx*(ii+1)/((nx+1)*(nx+2))
    #            beta1_xx = beta_cache_xx[ii+1,nx-ii+1]
    #            beta2_xx = beta_cache_xx[ii+2,nx-ii+1]
    #            value = numpy.sum(c1_xx*(beta1_xx[1:]-beta1_xx[:-1])
    #                              + c2_xx*(beta2_xx[1:]-beta2_xx[:-1]))
    #            data[ii,jj] = value
    #    fs = dadi.Spectrum(data, mask_corners=mask_corners)
    #    return fs

    @staticmethod
    def _from_phi_2D_linalg(nx, ny, xx, yy, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        if not (len(xx) == len(yy) and np.allclose(xx,yy)):
            raise ValueError(&#39;Must have xx==yy to use linear algebra calculation of FS from phi.&#39;)
        dbeta1_xx, dbeta2_xx = cached_dbeta(nx, xx)
        dbeta1_yy, dbeta2_yy = cached_dbeta(ny, yy)

        # For a somewhat less terse example of this code, see the
        # (archived) _from_phi_2D_analytic function.
        s_yy = (phi[:,1:] - phi[:,:-1])/(yy[nuax,1:] - yy[nuax,:-1])
        c1_yy = (phi[:,:-1] - s_yy*yy[nuax,:-1])/(ny+1)

        term1_yy = np.dot(dbeta1_yy,c1_yy.T)
        term2_yy = np.dot(dbeta2_yy, s_yy.T)
        term2_yy *= np.arange(1,ny+2)[:,np.newaxis]/((ny+1)*(ny+2))
        over_y_all = term1_yy + term2_yy

        s_xx_all = (over_y_all[:,1:] - over_y_all[:,:-1])/(xx[1:]-xx[:-1])
        c1_xx_all = (over_y_all[:,:-1] - s_xx_all*xx[:-1])/(nx+1)

        term1_all = np.dot(dbeta1_xx, c1_xx_all.T)
        term2_all = np.dot(dbeta2_xx, s_xx_all.T)
        term2_all *=  np.arange(1,nx+2)[:,np.newaxis]/((nx+1)*(nx+2))

        data = term1_all + term2_all

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_direct(nx, ny, nz, xx, yy, zz, phi, mask_corners=True,
                     het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1, ny+1, nz+1))
    
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
        half_dx = dx/2.0
    
        # We cache these calculations...
        factorx_cache, factory_cache = {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
    
        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zz**kk * (1-zz)**(nz-kk)
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            over_z = trapz(factorz[nuax, nuax,:] * phi, dx=dz)
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                over_y = trapz(factory * over_z, dx=dy)
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    # It&#39;s faster here to do the trapezoid rule explicitly
                    # rather than using SciPy&#39;s more general routine.
                    integrand = factorx * over_y
                    ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                    data[ii,jj,kk] = ans
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_4D_direct(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True,
                     het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1, ny+1, nz+1, na+1))
    
        dx, dy, dz, da = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz), np.diff(aa)
        half_dx = dx/2.0
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache = {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xx**ii * (1-xx)**(nx-ii)
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yy**jj * (1-yy)**(ny-jj)
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zz**kk * (1-zz)**(nz-kk)
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            factorz_cache[nz,kk] = factorz[nuax,nuax,:]
    
        for ll in range(0, na+1):
            factora = comb(na, ll) * aa**ll * (1-aa)**(na-ll)
            if het_ascertained == &#39;aa&#39;:
                factora *= aa*(1-aa)
            over_a = trapz(factora[nuax,nuax,nuax,:] * phi, dx=da)
            for kk in range(0, nz+1):
                factorz = factorz_cache[nz,kk]
                over_z = trapz(factorz * over_a, dx=dz)
                for jj in range(0, ny+1):
                    factory = factory_cache[ny,jj]
                    over_y = trapz(factory * over_z, dx=dy)
                    for ii in range(0, nx+1):
                        factorx = factorx_cache[nx,ii]
                        # It&#39;s faster here to do the trapezoid rule explicitly
                        # rather than using SciPy&#39;s more general routine.
                        integrand = factorx * over_y
                        ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                        data[ii,jj,kk,ll] = ans
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_direct_inbreeding(nx, ny, nz, xx, yy, zz, phi, Fx, Fy, Fz,
                                       mask_corners=True, ploidyx=2, ploidyy=2, ploidyz=2,
                                       het_ascertained=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        See from_phi_inbreeding for explanation of arguments.
        &#34;&#34;&#34;
        # Calculate the 2D sfs from phi using the trapezoid rule for
        # integration.
        if nx % ploidyx == 0:
            nIndx = nx/ploidyx
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 1.&#39;.format(str(nx),str(ploidyx)))
        
        if ny % ploidyy == 0:
            nIndy = ny/ploidyy
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 2.&#39;.format(str(ny),str(ploidyy)))
        
        if nz % ploidyz == 0:
            nIndz = nz/ploidyz
        else:
            raise ValueError(&#39;Number of chromosomes {0} is not divisible &#39;
                             &#39;by ploidy {1} for pop 3.&#39;.format(str(nz),str(ploidyz)))
        
        data = numpy.zeros((nx+1, ny+1, nz+1))
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
        half_dx = dx/2.0
        alphax = xx*((1.0-Fx)/Fx)
        alphax[0],alphax[-1] = 1.0e-20*((1.0-Fx)/Fx), (1.0-1.0e-20)*((1.0-Fx)/Fx)
        betax = (1.0-xx)*((1.0-Fx)/Fx)
        betax[0],betax[-1] = (1.0-1.0e-20)*((1.0-Fx)/Fx), 1.0e-20*((1.0-Fx)/Fx)
        alphay = yy*((1.0-Fy)/Fy)
        alphay[0],alphay[-1] = 1.0e-20*((1.0-Fy)/Fy), (1.0-1.0e-20)*((1.0-Fy)/Fy)
        betay = (1.0-yy)*((1.0-Fy)/Fy)
        betay[0],betay[-1] = (1.0-1.0e-20)*((1.0-Fy)/Fy), 1.0e-20*((1.0-Fy)/Fy)
        alphaz = zz*((1.0-Fz)/Fz)
        alphaz[0],alphaz[-1] = 1.0e-20*((1.0-Fz)/Fz), (1.0-1.0e-20)*((1.0-Fz)/Fz)
        betaz = (1.0-zz)*((1.0-Fz)/Fz)
        betaz[0],betaz[-1] = (1.0-1.0e-20)*((1.0-Fz)/Fz), 1.0e-20*((1.0-Fz)/Fz)
        
        # We cache these calculations...
        factorx_cache, factory_cache = {}, {}
        for ii in range(0, nx+1):
            factorx = numpy.array([BetaBinomConvolution(ii,nIndx,alphax[j],betax[j],ploidy=ploidyx) for j in range(0,len(xx))])
            if het_ascertained == &#39;xx&#39;:
                factorx *= xx*(1-xx)
            factorx_cache[nx,ii] = factorx
        for jj in range(0, ny+1):
            factory = numpy.array([BetaBinomConvolution(jj,nIndy,alphay[j],betay[j],ploidy=ploidyy) for j in range(0,len(yy))])
            if het_ascertained == &#39;yy&#39;:
                factory *= yy*(1-yy)
            factory_cache[ny,jj] = factory[nuax,:]
        
        for kk in range(0, nz+1):
            factorz = numpy.array([BetaBinomConvolution(kk,nIndz,alphaz[j],betaz[j],ploidy=ploidyz) for j in range(0,len(zz))])
            if het_ascertained == &#39;zz&#39;:
                factorz *= zz*(1-zz)
            over_z = trapz(factorz[nuax, nuax,:] * phi, dx=dz)
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                over_y = trapz(factory * over_z, dx=dy)
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    # It&#39;s faster here to do the trapezoid rule explicitly
                    # rather than using SciPy&#39;s more general routine.
                    integrand = factorx * over_y
                    ans = numpy.sum(half_dx * (integrand[1:]+integrand[:-1]))
                    data[ii,jj,kk] = ans
        
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_admix_props(nx, ny, nz, xx, yy, zz, phi, mask_corners=True,
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        if admix_props is None:
            admix_props = ((1,0,0), (0,1,0), (0,0,1))

        xadmix = admix_props[0][0]*xx[:,nuax,nuax]\
                + admix_props[0][1]*yy[nuax,:,nuax]\
                + admix_props[0][2]*zz[nuax,nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax,nuax]\
                + admix_props[1][1]*yy[nuax,:,nuax]\
                + admix_props[1][2]*zz[nuax,nuax,:]
        zadmix = admix_props[2][0]*xx[:,nuax,nuax]\
                + admix_props[2][1]*yy[nuax,:,nuax]\
                + admix_props[2][2]*zz[nuax,nuax,:]

        data = numpy.zeros((nx+1, ny+1, nz+1))
    
        dx, dy, dz = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz)
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache = {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx

        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            factory_cache[ny,jj] = factory

        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zadmix**kk * (1-zadmix)**(nz-kk)
            factorz_cache[nz,kk] = factorz
    
        for kk in range(0, nz+1):
            factorz = factorz_cache[nz,kk]
            for jj in range(0, ny+1):
                factory = factory_cache[ny,jj]
                for ii in range(0, nx+1):
                    factorx = factorx_cache[nx,ii]
                    over_z = trapz(factorz * factory * factorx * phi, dx=dz)
                    over_y = trapz(over_z, dx=dy)
                    data[ii,jj,kk] = trapz(over_y, dx=dx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_3D_linalg(nx, ny, nz, xx, yy, zz, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1))

        dbeta1_zz, dbeta2_zz = cached_dbeta(nz, zz)

        # Quick testing suggests that doing the x direction first for better
        # memory alignment isn&#39;t worth much.
        s_zz = (phi[:,:,1:]-phi[:,:,:-1])/(zz[nuax,nuax,1:]-zz[nuax,nuax,:-1])
        c1_zz = (phi[:,:,:-1] - s_zz*zz[nuax,nuax,:-1])/(nz+1)
        # These calculations can be done without this for loop, but the
        # four-dimensional intermediate results consume massive amounts of RAM,
        # which makes the for loop faster for large systems.
        for kk in range(0, nz+1):
            # In testing, these two np.dot lines occupy 2/3 the time, so further
            # speedup will be difficult
            term1 = np.dot(c1_zz, dbeta1_zz[kk])
            term2 = np.dot(s_zz, dbeta2_zz[kk])
            term2 *= (kk+1)/((nz+1)*(nz+2))
            over_z = term1 + term2

            sub_fs = Spectrum._from_phi_2D_linalg(nx, ny, xx, yy, over_z, raw=True)
            data[:,:,kk] = sub_fs.data

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_5D_linalg(nx, ny, nz, na, nb, xx, yy, zz, aa, bb, phi, mask_corners=True):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1,na+1,nb+1))

        dbeta1_bb, dbeta2_bb = cached_dbeta(nb, bb)

        s_bb = (phi[:,:,:,:,1:]-phi[:,:,:,:,:-1])/(bb[nuax,nuax,nuax,nuax,1:]-bb[nuax,nuax,nuax,nuax:-1])
        c1_bb = (phi[:,:,:,:,:-1] - s_bb*bb[nuax,nuax,nuax,nuax,:-1])/(nb+1)
        for mm in range(0, nb+1):
            term1 = np.dot(c1_bb, dbeta1_bb[mm])
            term2 = np.dot(s_bb, dbeta2_bb[mm])
            term2 *= (mm+1)/((nb+1)*(nb+2))
            over_b = term1 + term2

            sub_fs = Spectrum._from_phi_4D_linalg(nx, ny, nz, na, xx, yy, zz, aa, over_b, raw=True)
            data[:,:,:,:,mm] = sub_fs.data

        fs = dadi.Spectrum(data, mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_phi_4D_linalg(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True, raw=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        This function uses analytic formulae for integrating over a 
        piecewise-linear approximation to phi.

        See from_phi for explanation of arguments.

        raw: If True, return data as a numpy array, not a Spectrum object
        &#34;&#34;&#34;
        data = numpy.zeros((nx+1,ny+1,nz+1,na+1))

        dbeta1_aa, dbeta2_aa = cached_dbeta(na, aa)

        s_aa = (phi[:,:,:,1:]-phi[:,:,:,:-1])/(aa[nuax,nuax,nuax,1:]-aa[nuax,nuax,nuax:-1])
        c1_aa = (phi[:,:,:,:-1] - s_aa*aa[nuax,nuax,nuax,:-1])/(na+1)
        for ll in range(0, na+1):
            term1 = np.dot(c1_aa, dbeta1_aa[ll])
            term2 = np.dot(s_aa, dbeta2_aa[ll])
            term2 *= (ll+1)/((na+1)*(na+2))
            over_a = term1 + term2

            sub_fs = Spectrum._from_phi_3D_linalg(nx, ny, nz, xx, yy, zz, over_a, raw=True)
            data[:,:,:,ll] = sub_fs.data

        if raw:
            return data
        else:
            return dadi.Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def _from_phi_4D_admix_props(nx, ny, nz, na, xx, yy, zz, aa, phi, mask_corners=True,
                                 admix_props=None):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        See from_phi for explanation of arguments.
        &#34;&#34;&#34;
        if admix_props is None:
            admix_props = ((1,0,0,0), (0,1,0,0), (0,0,1,0), (0,0,0,1))

        xadmix = admix_props[0][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[0][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[0][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[0][3]*aa[nuax,nuax,nuax,:]
        yadmix = admix_props[1][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[1][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[1][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[1][3]*aa[nuax,nuax,nuax,:]
        zadmix = admix_props[2][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[2][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[2][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[2][3]*aa[nuax,nuax,nuax,:]
        aadmix = admix_props[3][0]*xx[:,nuax,nuax,nuax]\
                + admix_props[3][1]*yy[nuax,:,nuax,nuax]\
                + admix_props[3][2]*zz[nuax,nuax,:,nuax]\
                + admix_props[3][3]*aa[nuax,nuax,nuax,:]

        data = numpy.zeros((nx+1, ny+1, nz+1, na+1))
    
        dx, dy, dz, da = numpy.diff(xx), numpy.diff(yy), numpy.diff(zz), numpy.diff(aa)
    
        # We cache these calculations...
        factorx_cache, factory_cache, factorz_cache, factora_cache = {}, {}, {}, {}
        for ii in range(0, nx+1):
            factorx = comb(nx, ii) * xadmix**ii * (1-xadmix)**(nx-ii)
            factorx_cache[nx,ii] = factorx

        for jj in range(0, ny+1):
            factory = comb(ny, jj) * yadmix**jj * (1-yadmix)**(ny-jj)
            factory_cache[ny,jj] = factory

        for kk in range(0, nz+1):
            factorz = comb(nz, kk) * zadmix**kk * (1-zadmix)**(nz-kk)
            factorz_cache[nz,kk] = factorz

        for ll in range(0, na+1):
            factora = comb(na, ll) * aadmix**ll * (1-aadmix)**(na-ll)
            factora_cache[na,ll] = factora
    
        for ll in range(0, na+1):
            factora = factora_cache[na,ll]
            for kk in range(0, nz+1):
                factorz = factorz_cache[nz,kk]
                for jj in range(0, ny+1):
                    factory = factory_cache[ny,jj]
                    for ii in range(0, nx+1):
                        factorx = factorx_cache[nx,ii]
                        over_a = trapz(factora * factorz * factory * factorx * phi, dx=da)
                        over_z = trapz(over_a, dx=dz)
                        over_y = trapz(over_z, dx=dy)
                        data[ii,jj,kk,ll] = trapz(over_y, dx=dx)
    
        return Spectrum(data, mask_corners=mask_corners)

    @staticmethod
    def from_phi(phi, ns, xxs, mask_corners=True, 
                 pop_ids=None, admix_props=None, het_ascertained=None, 
                 force_direct=False):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi.

        phi: P-dimensional population frequency distribution.
        ns: Sequence of P sample sizes for each population.
        xxs: Sequence of P one-dimesional grids on which phi is defined.
        mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                      entries.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        admix_props: Admixture proportions for sampled individuals. For example,
                     if there are two populations, and individuals from the
                     first pop are admixed with fraction f from the second
                     population, then admix_props=((1-f,f),(0,1)). For three
                     populations, the no-admixture setting is
                     admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method.)
        het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                         population 2 or 3, respectively.
                         been ascertained by being heterozygous in one
                         individual from population 1. (This individual is
                         *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                         assumed that the ascertainment individual came from
                         population 2 or 3, respectively.
                         (Note that this option also forces direct integration,
                         which may be less accurate than the semi-analytic
                         method. This could be fixed if there is interest. Note
                         also that this option cannot be used simultaneously
                         with admix_props.)
        force_direct: Forces integration to use older direct integration method,
                      rather than using analytic integration of sampling 
                      formula.
        &#34;&#34;&#34;
        if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
            raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                             &#39;populations.&#39; .format(str(admix_props)))
        if not phi.ndim == len(ns) == len(xxs):
            raise ValueError(&#39;Dimensionality of phi and lengths of ns and xxs &#39;
                             &#39;do not all agree.&#39;)
        if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
            raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                             &#34;&#39;zz&#39;.&#34;)

        if admix_props and het_ascertained:
            error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
            simultaneously. Instead, please use the PhiManip methods to 
            implement admixture. If this proves inappropriate for your use, 
            contact the the dadi developers, as it may be possible to support
            both options simultaneously in the future.&#34;&#34;&#34;
            raise NotImplementedError(error)

        if phi.ndim == 1:
            if not het_ascertained and not force_direct:
                fs = Spectrum._from_phi_1D_analytic(ns[0], xxs[0], phi,
                                                    mask_corners)
            else:
                fs = Spectrum._from_phi_1D_direct(ns[0], xxs[0], phi, 
                                                  mask_corners, het_ascertained)
        elif phi.ndim == 2:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_2D_linalg(ns[0], ns[1], 
                                                  xxs[0], xxs[1], phi,
                                                  mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_2D_direct(ns[0], ns[1], xxs[0], xxs[1], 
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_2D_admix_props(ns[0], ns[1], 
                                                      xxs[0], xxs[1], 
                                                      phi, mask_corners, 
                                                      admix_props)
        elif phi.ndim == 3:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_3D_linalg(ns[0], ns[1], ns[2], 
                                                  xxs[0], xxs[1], xxs[2],
                                                  phi, mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_3D_direct(ns[0], ns[1], ns[2], 
                                                  xxs[0], xxs[1], xxs[2], 
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_3D_admix_props(ns[0], ns[1], ns[2], 
                                                       xxs[0], xxs[1], xxs[2], 
                                                       phi, mask_corners, 
                                                       admix_props)
        elif phi.ndim == 4:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_4D_linalg(ns[0], ns[1], ns[2], ns[3],
                                                  xxs[0], xxs[1], xxs[2], xxs[3],
                                                  phi, mask_corners)
            elif not admix_props:
                fs = Spectrum._from_phi_4D_direct(ns[0], ns[1], ns[2], ns[3],
                                                  xxs[0], xxs[1], xxs[2], xxs[3],
                                                  phi, mask_corners, 
                                                  het_ascertained)
            else:
                fs = Spectrum._from_phi_4D_admix_props(ns[0], ns[1], ns[2], ns[3],
                                                       xxs[0], xxs[1], xxs[2], xxs[3],
                                                       phi, mask_corners, 
                                                       admix_props)
        elif phi.ndim == 5:
            if not het_ascertained and not admix_props and not force_direct:
                fs = Spectrum._from_phi_5D_linalg(ns[0], ns[1], ns[2], ns[3], ns[4],
                                                  xxs[0], xxs[1], xxs[2], xxs[3], xxs[4],
                                                  phi, mask_corners)
        else:
            raise ValueError(&#39;Only implemented for dimensions 1-5.&#39;)
        fs.pop_ids = pop_ids
        # Record value to use for extrapolation. This is the first grid point,
        # which is where new mutations are introduced. Note that extrapolation
        # will likely fail if grids differ between dimensions.
        fs.extrap_x = xxs[0][1]
        for xx in xxs[1:]:
            if not xx[1] == fs.extrap_x:
                logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                            &#39;different dimensions. Extrapolation may fail.&#39;)
        return fs

    @staticmethod
    def from_phi_inbreeding(phi, ns, xxs, Fs, ploidys, mask_corners=True, 
                            pop_ids=None, admix_props=None,
                            het_ascertained=None, force_direct=True):
        &#34;&#34;&#34;
        Compute sample Spectrum from population frequency distribution phi
        plus inbreeding.
        
        phi: P-dimensional population frequency distribution.
        ns: Sequence of P sample sizes for each population.
        xxs: Sequence of P one-dimesional grids on which phi is defined.
        Fs: Sequence of P inbreeding coefficients for each population.
        ploidys: Sequence of P ploidy levels for each population.
        mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                      entries.
        pop_ids: Optional list of strings containing the population labels.
                 If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
        admix_props: Admixture proportions for sampled individuals. For example,
                     if there are two populations, and individuals from the
                     first pop are admixed with fraction f from the second
                     population, then admix_props=((1-f,f),(0,1)). For three
                     populations, the no-admixture setting is
                     admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method.)
        het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                         been ascertained by being heterozygous in one
                         individual from population 1. (This individual is
                         *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                         assumed that the ascertainment individual came from
                         population 2 or 3, respectively.
                         (Note that this option also forces direct integration,
                         which may be less accurate than the semi-analytic
                         method. This could be fixed if there is interest. Note
                         also that this option cannot be used simultaneously
                         with admix_props.)
        force_direct: Forces integration to use older direct integration method,
                      rather than using analytic integration of sampling 
                      formula.
        &#34;&#34;&#34;
        if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
            raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                             &#39;populations.&#39; .format(str(admix_props)))
        if not phi.ndim == len(ns) == len(xxs) == len(Fs) == len(ploidys):
            raise ValueError(&#39;Dimensionality of phi and lengths of ns, xxs, ploidys, and Fs &#39;
                             &#39;do not all agree.&#39;)
        if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
            raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                             &#34;&#39;zz&#39;.&#34;)

        if admix_props and het_ascertained:
            error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
            simultaneously. Instead, please use the PhiManip methods to 
            implement admixture. If this proves inappropriate for your use, 
            contact the the dadi developers, as it may be possible to support
            both options simultaneously in the future.&#34;&#34;&#34;
            raise NotImplementedError(error)

        if phi.ndim == 1:
            fs = Spectrum._from_phi_1D_direct_inbreeding(ns[0], xxs[0], phi, Fs[0],
                                                         mask_corners, ploidys[0],
                                                         het_ascertained)
        elif phi.ndim == 2:
            fs = Spectrum._from_phi_2D_direct_inbreeding(ns[0], ns[1], xxs[0], xxs[1],
                                                         phi, Fs[0], Fs[1], mask_corners,
                                                         ploidys[0], ploidys[1],
                                                         het_ascertained)
        elif phi.ndim == 3:
            fs = Spectrum._from_phi_3D_direct_inbreeding(ns[0], ns[1], ns[2], 
                                                         xxs[0], xxs[1], xxs[2], 
                                                         phi, Fs[0], Fs[1], Fs[2],
                                                         mask_corners, ploidys[0],
                                                         ploidys[1], ploidys[2],
                                                         het_ascertained)
        else:
            raise ValueError(&#39;Only implemented for dimensions 1,2 or 3.&#39;)
        fs.pop_ids = pop_ids
        # Record value to use for extrapolation. This is the first grid point,
        # which is where new mutations are introduced. Note that extrapolation
        # will likely fail if grids differ between dimensions.
        fs.extrap_x = xxs[0][1]
        for xx in xxs[1:]:
            if not xx[1] == fs.extrap_x:
                logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                            &#39;different dimensions. Extrapolation may fail.&#39;)
        return fs

    def scramble_pop_ids(self, mask_corners=True):
        &#34;&#34;&#34;
        Spectrum corresponding to scrambling individuals among populations.
        
        This is useful for assessing how diverged populations are.
        Essentially, it pools all the individuals represented in the fs and
        generates new populations of random individuals (without replacement)
        from that pool. If this fs is significantly different from the
        original, that implies population structure.
        &#34;&#34;&#34;
        original_folded = self.folded
        # If we started with an folded Spectrum, we need to unfold before
        # projecting.
        if original_folded:
            self = self.unfold()

        total_samp = numpy.sum(self.sample_sizes)
    
        # First generate a 1d sfs for the pooled population.
        combined = numpy.zeros(total_samp+1)
        # For each entry in the fs, this is the total number of derived alleles
        total_per_entry = self._total_per_entry()
        # Sum up to generate the equivalent 1-d spectrum.
        for derived,counts in zip(total_per_entry.ravel(), self.ravel()):
            combined[derived] += counts
    
        # Now resample back into a n-d spectrum
        # For each entry, this is the counts per popuation. 
        #  e.g. counts_per_entry[3,4,5] = [3,4,5]
        counts_per_entry = self._counts_per_entry()
        # Reshape it to be 1-d, so we can iterate over it easily.
        counts_per_entry = counts_per_entry.reshape(numpy.prod(self.shape), 
                                                    self.ndim)
        resamp = numpy.zeros(self.shape)
        for counts, derived in zip(counts_per_entry, total_per_entry.ravel()):
            # The probability here is 
            # (t1 choose d1)*(t2 choose d2)/(ntot choose derived)
            lnprob = sum(_lncomb(t,d) for t,d in zip(self.sample_sizes,counts))
            lnprob -= _lncomb(total_samp, derived)
            prob = numpy.exp(lnprob)
            # Assign result using the appropriate weighting
            resamp[tuple(counts)] += prob*combined[derived]

        resamp = Spectrum(resamp, mask_corners=mask_corners)
        if not original_folded:
            return resamp
        else:
            return resamp.fold()

    @staticmethod
    def from_data_dict(data_dict, pop_ids, projections, mask_corners=True,
                       polarized=True):
        &#34;&#34;&#34;
        Spectrum from a dictionary of polymorphisms.

        pop_ids: list of which populations to make fs for.
        projections: list of sample sizes to project down to for each
                     population.
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked.
        polarized: If True, the data are assumed to be correctly polarized by 
                   `outgroup_allele&#39;. SNPs in which the &#39;outgroup_allele&#39;
                   information is missing or &#39;-&#39; or not concordant with the
                   segregating alleles will be ignored.
                   If False, any &#39;outgroup_allele&#39; info present is ignored,
                   and the returned spectrum is folded.

        The data dictionary should be organized as:
            {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                     &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                                &#39;CEU&#39;: (7,3)
                                },
                     &#39;outgroup_allele&#39;: &#39;T&#39;
                    }
            }
        The &#39;calls&#39; entry gives the successful calls in each population, in the
        order that the alleles are specified in &#39;segregating&#39;.
        Non-diallelic polymorphisms are skipped.
        &#34;&#34;&#34;
        import dadi.Misc
        cd = dadi.Misc.count_data_dict(data_dict, pop_ids)
        fs = Spectrum._from_count_dict(cd, projections, polarized, pop_ids, 
                mask_corners=mask_corners)
        return fs

    @staticmethod
    def _from_count_dict(count_dict, projections, polarized=True, pop_ids=None,
            mask_corners=False):
        &#34;&#34;&#34;
        Frequency spectrum from data mapping SNP configurations to counts.

        count_dict: Result of Misc.count_data_dict
        projections: List of sample sizes to project down to for each
                     population.
        polarized: If True, only include SNPs that count_dict marks as
                   polarized.
                   If False, include all SNPs and fold resulting Spectrum.
        pop_ids: Optional list of strings containing the population labels.
        mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                      in all&#39; entries of the FS will be masked.
        &#34;&#34;&#34;
        # create slices for projection calculation
        slices = [[numpy.newaxis] * len(projections) for ii in
                  range(len(projections))]
        for ii in range(len(projections)):
            slices[ii][ii] = slice(None,None,None)
        # Convert to tuples to avoid numpy error
        slices = [tuple(_) for _ in slices]

        fs_total = dadi.Spectrum(numpy.zeros(numpy.array(projections)+1),
                                 pop_ids=pop_ids, mask_corners=mask_corners)
        for (called_by_pop, derived_by_pop, this_snp_polarized), count\
                in count_dict.items():
            if polarized and not this_snp_polarized:
                continue
            pop_contribs = []
            iter = zip(projections, called_by_pop, derived_by_pop)
            for pop_ii, (p_to, p_from, hits) in enumerate(iter):
                contrib = _cached_projection(p_to,p_from,hits)[slices[pop_ii]]
                pop_contribs.append(contrib)
            fs_proj = pop_contribs[0]
            for contrib in pop_contribs[1:]:
                fs_proj = fs_proj*contrib

            # create slices for adding projected fs to overall fs
            fs_total += count * fs_proj
        if polarized:
            return fs_total
        else:
            return fs_total.fold()

    @staticmethod
    def _data_by_tri(data_dict):
        &#34;&#34;&#34;
        Nest the data by derived context and outgroup base.

        The resulting dictionary contains only SNPs which are appropriate for
        use of Hernandez&#39;s ancestral misidentification correction. It is
        organized as {(derived_tri, outgroup_base): {snp_id: data,...}}
        &#34;&#34;&#34;
        result = {}
        genetic_bases = &#39;ACTG&#39;
        for snp, snp_info in data_dict.items():
            # Skip non-diallelic polymorphisms
            if len(snp_info[&#39;segregating&#39;]) != 2:
                continue
            allele1, allele2 = snp_info[&#39;segregating&#39;]
            # Filter out SNPs where we either non-constant ingroup or outgroup
            # context.
            try:
                ingroup_tri = snp_info[&#39;context&#39;]
                outgroup_tri = snp_info[&#39;outgroup_context&#39;]
            except KeyError:
                continue
            if not outgroup_tri[1] == snp_info[&#39;outgroup_allele&#39;]:
                raise ValueError(&#39;Outgroup context and allele are inconsistent &#39;
                                 &#39;for polymorphism: %s.&#39; % snp)
            outgroup_allele = outgroup_tri[1]
    
            # These are all the requirements to apply the ancestral correction.
            # First 2 are constant context.
            # Next 2 are sensible context.
            # Next 1 is that outgroup allele is one of the segregating.
            # Next 2 are that segregating alleles are sensible.
            if outgroup_tri[0] != ingroup_tri[0]\
               or outgroup_tri[2] != ingroup_tri[2]\
               or ingroup_tri[0] not in genetic_bases\
               or ingroup_tri[2] not in genetic_bases\
               or outgroup_allele not in [allele1, allele2]\
               or allele1 not in genetic_bases\
               or allele2 not in genetic_bases:
                continue
    
            if allele1 == outgroup_allele:
                derived_allele = allele2
            elif allele2 == outgroup_allele:
                # In this case, the second allele is non_outgroup
                derived_allele = allele1
            derived_tri = ingroup_tri[0] + derived_allele + ingroup_tri[2]
            result.setdefault((derived_tri, outgroup_allele), {})
            result[derived_tri, outgroup_allele][snp] = snp_info
        return result
    
    @staticmethod
    def from_data_dict_corrected(data_dict, pop_ids, projections,
                                 fux_filename, force_pos=True,
                                 mask_corners=True):
        &#34;&#34;&#34;
        Spectrum from a dictionary of polymorphisms, corrected for ancestral
        misidentification.

        The correction is based upon:
            Hernandez, Williamson &amp; Bustamante _Mol_Biol_Evol_ 24:1792 (2007)

        force_pos: If the correction is too agressive, it may leave some small
                   entries in the fs less than zero. If force_pos is true,
                   these entries will be set to zero, in such a way that the
                   total number of segregating SNPs is conserved.
        fux_filename: The name of the file containing the 
                   misidentification probabilities.
                   The file is of the form:
                       # Any number of comments lines beginning with #
                       AAA T 0.001
                       AAA G 0.02
                       ...
                   Where every combination of three + one bases is considered
                   (order is not important).  The triplet is the context and
                   putatively derived allele (x) in the reference species. The
                   single base is the base (u) in the outgroup. The numerical
                   value is 1-f_{ux} in the notation of the paper.

        The data dictionary should be organized as:
            {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                     &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                                &#39;CEU&#39;: (7,3)
                                },
                     &#39;outgroup_allele&#39;: &#39;T&#39;,
                     &#39;context&#39;: &#39;CAT&#39;,
                     &#39;outgroup_context&#39;: &#39;CAT&#39;
                    }
            }
        The additional entries are &#39;context&#39;, which includes the two flanking
        bases in the species of interest, and &#39;outgroup_context&#39;, which
        includes the aligned bases in the outgroup.

        This method skips entries for which the correction cannot be applied.
        Most commonly this is because of missing or non-constant context.
        &#34;&#34;&#34;
        # Read the fux file into a dictionary.
        fux_dict = {}
        f = open(fux_filename)
        for line in f.readlines():
            if line.startswith(&#39;#&#39;):
                continue
            sp = line.split()
            fux_dict[(sp[0], sp[1])] = 1-float(sp[2])
        f.close()
    
        # Divide the data into classes based on (&#39;context&#39;, &#39;outgroup_allele&#39;)
        by_context = Spectrum._data_by_tri(data_dict)
    
        fs = numpy.zeros(numpy.asarray(projections)+1)
        while by_context:
            # Each time through this loop, we eliminate two entries from the 
            # data dictionary. These correspond to one class and its
            # corresponding misidentified class.
            (derived_tri, out_base), nomis_data = by_context.popitem()

            # The corresponding bases if the ancestral state had been
            # misidentifed.
            mis_out_base = derived_tri[1]
            mis_derived_tri = derived_tri[0] + out_base + derived_tri[2]
            # Get the data for that case. Note that we default to an empty
            # dictionary if we don&#39;t have data for that class.
            mis_data = by_context.pop((mis_derived_tri, mis_out_base), {})
    
            fux = fux_dict[(derived_tri, out_base)]
            fxu = fux_dict[(mis_derived_tri, mis_out_base)]
    
            # Get the spectra for these two cases
            Nux = Spectrum.from_data_dict(nomis_data, pop_ids, projections)
            Nxu = Spectrum.from_data_dict(mis_data, pop_ids, projections)
    
            # Equations 5 &amp; 6 from the paper.
            Nxu_rev = reverse_array(Nxu)
            Rux = (fxu*Nux - (1-fxu)*Nxu_rev)/(fux+fxu-1)
            Rxu = reverse_array((fux*Nxu_rev - (1-fux)*Nux)/(fux+fxu-1))
    
            fs += Rux + Rxu
    
        # Here we take the negative entries, and flip them back, so they end up
        # zero and the total number of SNPs is conserved.
        if force_pos:
            negative_entries = numpy.minimum(0, fs)
            fs -= negative_entries
            fs += reverse_array(negative_entries)
    
        return Spectrum(fs, mask_corners=mask_corners, pop_ids=pop_ids)

    # The code below ensures that when I do arithmetic with Spectrum objects,
    # it is not done between a folded and an unfolded array. If it is, I raise
    # a ValueError.

    # While I&#39;m at it, I&#39;m also fixing the annoying behavior that if a1 and a2
    # are masked arrays, and a3 = a1 + a2. Then wherever a1 or a2 was masked,
    # a3.data ends up with the a1.data values, rather than a1.data + a2.data.
    # Note that this fix doesn&#39;t work for operation by numpy.ma.exp and 
    # numpy.ma.log. Guess I can&#39;t have everything.

    # I&#39;m using exec here to avoid copy-pasting a dozen boiler-plate functions.
    # The calls to check_folding_equal ensure that we don&#39;t try to combine
    # folded and unfolded Spectrum objects.

    # I set check_folding = False in the constructor because it raises useless
    # warnings when, for example, I do (model + 1). 

    # These functions also ensure that the pop_ids and extrap_x attributes
    # get properly copied over.

    # This is pretty advanced Python voodoo, so don&#39;t fret if you don&#39;t
    # understand it at first glance. :-)
    for method in [&#39;__add__&#39;,&#39;__radd__&#39;,&#39;__sub__&#39;,&#39;__rsub__&#39;,&#39;__mul__&#39;,
                   &#39;__rmul__&#39;,&#39;__div__&#39;,&#39;__rdiv__&#39;,&#39;__truediv__&#39;,&#39;__rtruediv__&#39;,
                   &#39;__floordiv__&#39;,&#39;__rfloordiv__&#39;,&#39;__rpow__&#39;,&#39;__pow__&#39;]:
        exec(&#34;&#34;&#34;
def %(method)s(self, other):
    self._check_other_folding(other)
    if isinstance(other, numpy.ma.masked_array):
        newdata = self.data.%(method)s (other.data)
        newmask = numpy.ma.mask_or(self.mask, other.mask)
    else:
        newdata = self.data.%(method)s (other)
        newmask = self.mask
    newpop_ids = self.pop_ids
    if hasattr(other, &#39;pop_ids&#39;):
        if other.pop_ids is None:
            newpop_ids = self.pop_ids
        elif self.pop_ids is None:
            newpop_ids = other.pop_ids
        elif other.pop_ids != self.pop_ids:
            logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;
                        &#39;Resulting pop_id may not be correct.&#39;)
    if hasattr(other, &#39;extrap_x&#39;) and self.extrap_x != other.extrap_x:
        extrap_x = None
    else:
        extrap_x = self.extrap_x
    outfs = self.__class__.__new__(self.__class__, newdata, newmask, 
                                   mask_corners=False, data_folded=self.folded,
                                   check_folding=False, pop_ids=newpop_ids,
                                   extrap_x=extrap_x)
    return outfs
&#34;&#34;&#34; % {&#39;method&#39;:method})

    # Methods that modify the Spectrum in-place.
    for method in [&#39;__iadd__&#39;,&#39;__isub__&#39;,&#39;__imul__&#39;,&#39;__idiv__&#39;,
                   &#39;__itruediv__&#39;,&#39;__ifloordiv__&#39;,&#39;__ipow__&#39;]:
        exec(&#34;&#34;&#34;
def %(method)s(self, other):
    self._check_other_folding(other)
    if isinstance(other, numpy.ma.masked_array):
        self.data.%(method)s (other.data)
        self.mask = numpy.ma.mask_or(self.mask, other.mask)
    else:
        self.data.%(method)s (other)
    if hasattr(other, &#39;pop_ids&#39;) and other.pop_ids is not None\
             and other.pop_ids != self.pop_ids:
        logger.warn(&#39;Arithmetic between Spectra with different pop_ids. &#39;
                    &#39;Resulting pop_id may not be correct.&#39;)
    if hasattr(other, &#39;extrap_x&#39;) and self.extrap_x != other.extrap_x:
        self.extrap_x = None
    return self
&#34;&#34;&#34; % {&#39;method&#39;:method})

    def _check_other_folding(self, other):
        &#34;&#34;&#34;
        Ensure other Spectrum has same .folded status
        &#34;&#34;&#34;
        if isinstance(other, self.__class__)\
           and other.folded != self.folded:
            raise ValueError(&#39;Cannot operate with a folded Spectrum and an &#39;
                             &#39;unfolded one.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>numpy.ma.core.MaskedArray</li>
<li>numpy.ndarray</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum.method"><code class="name">var <span class="ident">method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum.from_data_dict"><code class="name flex">
<span>def <span class="ident">from_data_dict</span></span>(<span>data_dict, pop_ids, projections, mask_corners=True, polarized=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Spectrum from a dictionary of polymorphisms.</p>
<p>pop_ids: list of which populations to make fs for.
projections: list of sample sizes to project down to for each
population.
mask_corners: If True (default), the 'observed in none' and 'observed
in all' entries of the FS will be masked.
polarized: If True, the data are assumed to be correctly polarized by
`outgroup_allele'. SNPs in which the 'outgroup_allele'
information is missing or '-' or not concordant with the
segregating alleles will be ignored.
If False, any 'outgroup_allele' info present is ignored,
and the returned spectrum is folded.</p>
<p>The data dictionary should be organized as:
{snp_id:{'segregating': ['A','T'],
'calls': {'YRI': (23,3),
'CEU': (7,3)
},
'outgroup_allele': 'T'
}
}
The 'calls' entry gives the successful calls in each population, in the
order that the alleles are specified in 'segregating'.
Non-diallelic polymorphisms are skipped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_data_dict(data_dict, pop_ids, projections, mask_corners=True,
                   polarized=True):
    &#34;&#34;&#34;
    Spectrum from a dictionary of polymorphisms.

    pop_ids: list of which populations to make fs for.
    projections: list of sample sizes to project down to for each
                 population.
    mask_corners: If True (default), the &#39;observed in none&#39; and &#39;observed 
                  in all&#39; entries of the FS will be masked.
    polarized: If True, the data are assumed to be correctly polarized by 
               `outgroup_allele&#39;. SNPs in which the &#39;outgroup_allele&#39;
               information is missing or &#39;-&#39; or not concordant with the
               segregating alleles will be ignored.
               If False, any &#39;outgroup_allele&#39; info present is ignored,
               and the returned spectrum is folded.

    The data dictionary should be organized as:
        {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                 &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                            &#39;CEU&#39;: (7,3)
                            },
                 &#39;outgroup_allele&#39;: &#39;T&#39;
                }
        }
    The &#39;calls&#39; entry gives the successful calls in each population, in the
    order that the alleles are specified in &#39;segregating&#39;.
    Non-diallelic polymorphisms are skipped.
    &#34;&#34;&#34;
    import dadi.Misc
    cd = dadi.Misc.count_data_dict(data_dict, pop_ids)
    fs = Spectrum._from_count_dict(cd, projections, polarized, pop_ids, 
            mask_corners=mask_corners)
    return fs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_data_dict_corrected"><code class="name flex">
<span>def <span class="ident">from_data_dict_corrected</span></span>(<span>data_dict, pop_ids, projections, fux_filename, force_pos=True, mask_corners=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Spectrum from a dictionary of polymorphisms, corrected for ancestral
misidentification.</p>
<p>The correction is based upon:
Hernandez, Williamson &amp; Bustamante <em>Mol_Biol_Evol</em> 24:1792 (2007)</p>
<p>force_pos: If the correction is too agressive, it may leave some small
entries in the fs less than zero. If force_pos is true,
these entries will be set to zero, in such a way that the
total number of segregating SNPs is conserved.
fux_filename: The name of the file containing the
misidentification probabilities.
The file is of the form:
# Any number of comments lines beginning with #
AAA T 0.001
AAA G 0.02
&hellip;
Where every combination of three + one bases is considered
(order is not important).
The triplet is the context and
putatively derived allele (x) in the reference species. The
single base is the base (u) in the outgroup. The numerical
value is 1-f_{ux} in the notation of the paper.</p>
<p>The data dictionary should be organized as:
{snp_id:{'segregating': ['A','T'],
'calls': {'YRI': (23,3),
'CEU': (7,3)
},
'outgroup_allele': 'T',
'context': 'CAT',
'outgroup_context': 'CAT'
}
}
The additional entries are 'context', which includes the two flanking
bases in the species of interest, and 'outgroup_context', which
includes the aligned bases in the outgroup.</p>
<p>This method skips entries for which the correction cannot be applied.
Most commonly this is because of missing or non-constant context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_data_dict_corrected(data_dict, pop_ids, projections,
                             fux_filename, force_pos=True,
                             mask_corners=True):
    &#34;&#34;&#34;
    Spectrum from a dictionary of polymorphisms, corrected for ancestral
    misidentification.

    The correction is based upon:
        Hernandez, Williamson &amp; Bustamante _Mol_Biol_Evol_ 24:1792 (2007)

    force_pos: If the correction is too agressive, it may leave some small
               entries in the fs less than zero. If force_pos is true,
               these entries will be set to zero, in such a way that the
               total number of segregating SNPs is conserved.
    fux_filename: The name of the file containing the 
               misidentification probabilities.
               The file is of the form:
                   # Any number of comments lines beginning with #
                   AAA T 0.001
                   AAA G 0.02
                   ...
               Where every combination of three + one bases is considered
               (order is not important).  The triplet is the context and
               putatively derived allele (x) in the reference species. The
               single base is the base (u) in the outgroup. The numerical
               value is 1-f_{ux} in the notation of the paper.

    The data dictionary should be organized as:
        {snp_id:{&#39;segregating&#39;: [&#39;A&#39;,&#39;T&#39;],
                 &#39;calls&#39;: {&#39;YRI&#39;: (23,3),
                            &#39;CEU&#39;: (7,3)
                            },
                 &#39;outgroup_allele&#39;: &#39;T&#39;,
                 &#39;context&#39;: &#39;CAT&#39;,
                 &#39;outgroup_context&#39;: &#39;CAT&#39;
                }
        }
    The additional entries are &#39;context&#39;, which includes the two flanking
    bases in the species of interest, and &#39;outgroup_context&#39;, which
    includes the aligned bases in the outgroup.

    This method skips entries for which the correction cannot be applied.
    Most commonly this is because of missing or non-constant context.
    &#34;&#34;&#34;
    # Read the fux file into a dictionary.
    fux_dict = {}
    f = open(fux_filename)
    for line in f.readlines():
        if line.startswith(&#39;#&#39;):
            continue
        sp = line.split()
        fux_dict[(sp[0], sp[1])] = 1-float(sp[2])
    f.close()

    # Divide the data into classes based on (&#39;context&#39;, &#39;outgroup_allele&#39;)
    by_context = Spectrum._data_by_tri(data_dict)

    fs = numpy.zeros(numpy.asarray(projections)+1)
    while by_context:
        # Each time through this loop, we eliminate two entries from the 
        # data dictionary. These correspond to one class and its
        # corresponding misidentified class.
        (derived_tri, out_base), nomis_data = by_context.popitem()

        # The corresponding bases if the ancestral state had been
        # misidentifed.
        mis_out_base = derived_tri[1]
        mis_derived_tri = derived_tri[0] + out_base + derived_tri[2]
        # Get the data for that case. Note that we default to an empty
        # dictionary if we don&#39;t have data for that class.
        mis_data = by_context.pop((mis_derived_tri, mis_out_base), {})

        fux = fux_dict[(derived_tri, out_base)]
        fxu = fux_dict[(mis_derived_tri, mis_out_base)]

        # Get the spectra for these two cases
        Nux = Spectrum.from_data_dict(nomis_data, pop_ids, projections)
        Nxu = Spectrum.from_data_dict(mis_data, pop_ids, projections)

        # Equations 5 &amp; 6 from the paper.
        Nxu_rev = reverse_array(Nxu)
        Rux = (fxu*Nux - (1-fxu)*Nxu_rev)/(fux+fxu-1)
        Rxu = reverse_array((fux*Nxu_rev - (1-fux)*Nux)/(fux+fxu-1))

        fs += Rux + Rxu

    # Here we take the negative entries, and flip them back, so they end up
    # zero and the total number of SNPs is conserved.
    if force_pos:
        negative_entries = numpy.minimum(0, fs)
        fs -= negative_entries
        fs += reverse_array(negative_entries)

    return Spectrum(fs, mask_corners=mask_corners, pop_ids=pop_ids)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>fname, mask_corners=True, return_comments=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read frequency spectrum from file.</p>
<p>fname: String with file name to read from. If it ends in .gz, gzip
compression is assumed.
mask_corners: If True, mask the 'absent in all samples' and 'fixed in
all samples' entries.
return_comments: If true, the return value is (fs, comments), where
comments is a list of strings containing the comments
from the file (without #'s).</p>
<p>See to_file method for details on the file format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_file(fname, mask_corners=True, return_comments=False):
    &#34;&#34;&#34;
    Read frequency spectrum from file.

    fname: String with file name to read from. If it ends in .gz, gzip
           compression is assumed.
    mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                  all samples&#39; entries.
    return_comments: If true, the return value is (fs, comments), where
                     comments is a list of strings containing the comments
                     from the file (without #&#39;s).

    See to_file method for details on the file format.
    &#34;&#34;&#34;
    if fname.endswith(&#39;.gz&#39;):
        fid = gzip.open(fname, &#39;rb&#39;)
    else:
        fid = open(fname, &#39;r&#39;)

    line = fid.readline()
    # Strip out the comments
    comments = []
    while line.startswith(&#39;#&#39;):
        comments.append(line[1:].strip())
        line = fid.readline()

    # Read the shape of the data
    shape_spl = line.split()
    if &#39;folded&#39; not in shape_spl and &#39;unfolded&#39; not in shape_spl:
        # This case handles the old file format
        shape = tuple([int(d) for d in shape_spl])
        folded = False
        pop_ids = None
    else:
        # This case handles the new file format
        shape,next_ii = [int(shape_spl[0])], 1
        while shape_spl[next_ii] not in [&#39;folded&#39;, &#39;unfolded&#39;]:
            shape.append(int(shape_spl[next_ii]))
            next_ii += 1
        folded = (shape_spl[next_ii] == &#39;folded&#39;)
        # Are there population labels in the file?
        if len(shape_spl) &gt; next_ii + 1:
            pop_ids = line.split(&#39;&#34;&#39;)[1::2]
        else:
            pop_ids = None

    data = numpy.fromstring(fid.readline().strip(), 
                            count=numpy.product(shape), sep=&#39; &#39;)
    # fromfile returns a 1-d array. Reshape it to the proper form.
    data = data.reshape(*shape)

    maskline = fid.readline().strip()
    if not maskline:
        # The old file format didn&#39;t have a line for the mask
        mask = None
    else:
        # This case handles the new file format
        mask = numpy.fromstring(maskline, 
                                count=numpy.product(shape), sep=&#39; &#39;)
        mask = mask.reshape(*shape)

    fs = Spectrum(data, mask, mask_corners, data_folded=folded,
                  pop_ids=pop_ids)

    fid.close()
    if not return_comments:
        return fs
    else:
        return fs,comments</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_ms_file"><code class="name flex">
<span>def <span class="ident">from_ms_file</span></span>(<span>fid, average=True, mask_corners=True, return_header=False, pop_assignments=None, pop_ids=None, bootstrap_segments=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Read frequency spectrum from file of ms output.</p>
<p>fid: string with file name to read from or an open file object.
average: If True, the returned fs is the average over the runs in the ms
file. If False, the returned fs is the sum.
mask_corners: If True, mask the 'absent in all samples' and 'fixed in
all samples' entries.
return_header: If True, the return value is (fs, (command,seeds), where
command and seeds are strings containing the ms
commandline and the seeds used.
pop_assignments: If None, the assignments of samples to populations is
done automatically, using the assignment in the ms
command line. To manually assign populations, pass a
list of the from [6,8]. This example places
the first 6 samples into population 1, and the next 8
into population 2.
pop_ids: Optional list of strings containing the population labels.
If pop_ids is None, labels will be "pop0", "pop1", &hellip;
bootstrap_segments: If bootstrap_segments is an integer greater than 1,
the data will be broken up into that many segments
based on SNP position. Instead of single FS, a list
of spectra will be returned, one for each segment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_ms_file(fid, average=True, mask_corners=True, return_header=False,
                 pop_assignments=None, pop_ids=None, bootstrap_segments=1):
    &#34;&#34;&#34;
    Read frequency spectrum from file of ms output.

    fid: string with file name to read from or an open file object.
    average: If True, the returned fs is the average over the runs in the ms
             file. If False, the returned fs is the sum.
    mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                  all samples&#39; entries.
    return_header: If True, the return value is (fs, (command,seeds), where
                   command and seeds are strings containing the ms
                   commandline and the seeds used.
    pop_assignments: If None, the assignments of samples to populations is
                     done automatically, using the assignment in the ms
                     command line. To manually assign populations, pass a
                     list of the from [6,8]. This example places
                     the first 6 samples into population 1, and the next 8
                     into population 2.
    pop_ids: Optional list of strings containing the population labels.
             If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
    bootstrap_segments: If bootstrap_segments is an integer greater than 1,
                        the data will be broken up into that many segments
                        based on SNP position. Instead of single FS, a list
                        of spectra will be returned, one for each segment.
    &#34;&#34;&#34;
    newfile = False
    # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
    # use to open a file.
    if not hasattr(fid, &#39;read&#39;):
        newfile = True
        fid = open(fid, &#39;r&#39;)

    # Parse the commandline
    command = line = fid.readline()
    command_terms = line.split()
    
    if command_terms[0].count(&#39;ms&#39;):
        runs = int(command_terms[2])
        try:
            pop_flag = command_terms.index(&#39;-I&#39;)
            num_pops = int(command_terms[pop_flag+1])
            pop_samples = [int(command_terms[pop_flag+ii])
                           for ii in range(2, 2+num_pops)]
        except ValueError:
            num_pops = 1
            pop_samples = [int(command_terms[1])]
    else:
        raise ValueError(&#39;Unrecognized command string: %s.&#39; % command)
    
    total_samples = numpy.sum(pop_samples)
    if pop_assignments:
        num_pops = len(pop_assignments)
        pop_samples = pop_assignments

    sample_indices = numpy.cumsum([0] + pop_samples)
    bottom_l = sample_indices[:-1]
    top_l = sample_indices[1:]
    
    seeds = line = fid.readline()
    while not line.startswith(&#39;//&#39;):
        line = fid.readline()
    
    counts = numpy.zeros(len(pop_samples), numpy.int_)
    fs_shape = numpy.asarray(pop_samples) + 1
    dimension = len(counts)
    
    if dimension &gt; 1:
        bottom0 = bottom_l[0]
        top0 = top_l[0]
        bottom1 = bottom_l[1]
        top1 = top_l[1]
    if dimension &gt; 2:
        bottom2 = bottom_l[2]
        top2 = top_l[2]
    if dimension &gt; 3:
        bottom3 = bottom_l[3]
        top3 = top_l[3]
    if dimension &gt; 4:
        bottom4 = bottom_l[4]
        top4 = top_l[4]
    if dimension &gt; 5:
        bottom5 = bottom_l[5]
        top5 = top_l[5]
    
    all_data = [numpy.zeros(fs_shape, numpy.int_)
                for boot_ii in range(bootstrap_segments)]
    for run_ii in range(runs):
        line = fid.readline()
        segsites = int(line.split()[-1])
        
        if segsites == 0:
            # Special case, need to read 3 lines to stay synced.
            for _ in range(3):
                line = fid.readline()
            continue
        line = fid.readline()
        while not line.startswith(&#39;positions&#39;):
            line = fid.readline()

        # Read SNP positions for creating bootstrap segments
        positions = [float(_) for _ in line.split()[1:]]
        # Where we should break our interval to create our bootstraps
        breakpts = numpy.linspace(0, 1, bootstrap_segments+1)
        # The indices that correspond to those breakpoints
        break_iis = numpy.searchsorted(positions, breakpts)
        # Correct for searchsorted behavior if last position is 1,
        # to ensure all SNPs are captured
        break_iis[-1] = len(positions)
    
        # Read the chromosomes in
        chromos = fid.read((segsites+1)*total_samples)
    
        # For each bootstrap segment, relevant SNPs run from start_ii:end_ii
        for boot_ii, (start_ii, end_ii) \
                in enumerate(zip(break_iis[:-1], break_iis[1:])):
            # Use the data array corresponding to this bootstrap segment
            data = all_data[boot_ii]
            for snp in range(start_ii, end_ii):
                # Slice to get all the entries that refer to a given SNP
                this_snp = chromos[snp::segsites+1]
                # Count SNPs per population, and record them.
                if dimension == 1:
                    data[this_snp.count(&#39;1&#39;)] += 1
                elif dimension == 2:
                    data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                         this_snp[bottom1:top1].count(&#39;1&#39;)] += 1
                elif dimension == 3:
                    data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                         this_snp[bottom1:top1].count(&#39;1&#39;),
                         this_snp[bottom2:top2].count(&#39;1&#39;)] += 1
                elif dimension == 4:
                    data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                         this_snp[bottom1:top1].count(&#39;1&#39;),
                         this_snp[bottom2:top2].count(&#39;1&#39;),
                         this_snp[bottom3:top3].count(&#39;1&#39;)] += 1
                elif dimension == 5:
                    data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                         this_snp[bottom1:top1].count(&#39;1&#39;),
                         this_snp[bottom2:top2].count(&#39;1&#39;),
                         this_snp[bottom3:top3].count(&#39;1&#39;),
                         this_snp[bottom4:top4].count(&#39;1&#39;)] += 1
                elif dimension == 6:
                    data[this_snp[bottom0:top0].count(&#39;1&#39;), 
                         this_snp[bottom1:top1].count(&#39;1&#39;),
                         this_snp[bottom2:top2].count(&#39;1&#39;),
                         this_snp[bottom3:top3].count(&#39;1&#39;),
                         this_snp[bottom4:top4].count(&#39;1&#39;),
                         this_snp[bottom5:top5].count(&#39;1&#39;)] += 1
                else:
                    # This is noticably slower, so we special case the cases
                    # above.
                    for dim_ii in range(dimension):
                        bottom = bottom_l[dim_ii]
                        top = top_l[dim_ii]
                        counts[dim_ii] = this_snp[bottom:top].count(&#39;1&#39;)
                    data[tuple(counts)] += 1
    
        # Read to the next iteration
        line = fid.readline()
        line = fid.readline()

    if newfile:
        fid.close()

    all_fs = [Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
              for data in all_data]
    if average:
        all_fs = [fs/runs for fs in all_fs]

    # If we aren&#39;t setting up for bootstrapping, return fs, rather than a
    # list of length 1. (This ensures backward compatibility.)
    if bootstrap_segments == 1:
        all_fs = all_fs[0]

    if not return_header:
        return all_fs
    else:
        return all_fs, (command,seeds)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_phi"><code class="name flex">
<span>def <span class="ident">from_phi</span></span>(<span>phi, ns, xxs, mask_corners=True, pop_ids=None, admix_props=None, het_ascertained=None, force_direct=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute sample Spectrum from population frequency distribution phi.</p>
<p>phi: P-dimensional population frequency distribution.
ns: Sequence of P sample sizes for each population.
xxs: Sequence of P one-dimesional grids on which phi is defined.
mask_corners: If True, resulting FS is masked in 'absent' and 'fixed'
entries.
pop_ids: Optional list of strings containing the population labels.
If pop_ids is None, labels will be "pop0", "pop1", &hellip;
admix_props: Admixture proportions for sampled individuals. For example,
if there are two populations, and individuals from the
first pop are admixed with fraction f from the second
population, then admix_props=((1-f,f),(0,1)). For three
populations, the no-admixture setting is
admix_props=((1,0,0),(0,1,0),(0,0,1)).
(Note that this option also forces direct integration,
which may be less accurate than the semi-analytic
method.)
het_ascertained: If 'xx', then FS is calculated assuming that SNPs have
population 2 or 3, respectively.
been ascertained by being heterozygous in one
individual from population 1. (This individual is
<em>not</em> in the current sample.) If 'yy' or 'zz', it
assumed that the ascertainment individual came from
population 2 or 3, respectively.
(Note that this option also forces direct integration,
which may be less accurate than the semi-analytic
method. This could be fixed if there is interest. Note
also that this option cannot be used simultaneously
with admix_props.)
force_direct: Forces integration to use older direct integration method,
rather than using analytic integration of sampling
formula.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_phi(phi, ns, xxs, mask_corners=True, 
             pop_ids=None, admix_props=None, het_ascertained=None, 
             force_direct=False):
    &#34;&#34;&#34;
    Compute sample Spectrum from population frequency distribution phi.

    phi: P-dimensional population frequency distribution.
    ns: Sequence of P sample sizes for each population.
    xxs: Sequence of P one-dimesional grids on which phi is defined.
    mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                  entries.
    pop_ids: Optional list of strings containing the population labels.
             If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
    admix_props: Admixture proportions for sampled individuals. For example,
                 if there are two populations, and individuals from the
                 first pop are admixed with fraction f from the second
                 population, then admix_props=((1-f,f),(0,1)). For three
                 populations, the no-admixture setting is
                 admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                 (Note that this option also forces direct integration,
                 which may be less accurate than the semi-analytic
                 method.)
    het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                     population 2 or 3, respectively.
                     been ascertained by being heterozygous in one
                     individual from population 1. (This individual is
                     *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                     assumed that the ascertainment individual came from
                     population 2 or 3, respectively.
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method. This could be fixed if there is interest. Note
                     also that this option cannot be used simultaneously
                     with admix_props.)
    force_direct: Forces integration to use older direct integration method,
                  rather than using analytic integration of sampling 
                  formula.
    &#34;&#34;&#34;
    if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
        raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                         &#39;populations.&#39; .format(str(admix_props)))
    if not phi.ndim == len(ns) == len(xxs):
        raise ValueError(&#39;Dimensionality of phi and lengths of ns and xxs &#39;
                         &#39;do not all agree.&#39;)
    if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
        raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                         &#34;&#39;zz&#39;.&#34;)

    if admix_props and het_ascertained:
        error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
        simultaneously. Instead, please use the PhiManip methods to 
        implement admixture. If this proves inappropriate for your use, 
        contact the the dadi developers, as it may be possible to support
        both options simultaneously in the future.&#34;&#34;&#34;
        raise NotImplementedError(error)

    if phi.ndim == 1:
        if not het_ascertained and not force_direct:
            fs = Spectrum._from_phi_1D_analytic(ns[0], xxs[0], phi,
                                                mask_corners)
        else:
            fs = Spectrum._from_phi_1D_direct(ns[0], xxs[0], phi, 
                                              mask_corners, het_ascertained)
    elif phi.ndim == 2:
        if not het_ascertained and not admix_props and not force_direct:
            fs = Spectrum._from_phi_2D_linalg(ns[0], ns[1], 
                                              xxs[0], xxs[1], phi,
                                              mask_corners)
        elif not admix_props:
            fs = Spectrum._from_phi_2D_direct(ns[0], ns[1], xxs[0], xxs[1], 
                                              phi, mask_corners, 
                                              het_ascertained)
        else:
            fs = Spectrum._from_phi_2D_admix_props(ns[0], ns[1], 
                                                  xxs[0], xxs[1], 
                                                  phi, mask_corners, 
                                                  admix_props)
    elif phi.ndim == 3:
        if not het_ascertained and not admix_props and not force_direct:
            fs = Spectrum._from_phi_3D_linalg(ns[0], ns[1], ns[2], 
                                              xxs[0], xxs[1], xxs[2],
                                              phi, mask_corners)
        elif not admix_props:
            fs = Spectrum._from_phi_3D_direct(ns[0], ns[1], ns[2], 
                                              xxs[0], xxs[1], xxs[2], 
                                              phi, mask_corners, 
                                              het_ascertained)
        else:
            fs = Spectrum._from_phi_3D_admix_props(ns[0], ns[1], ns[2], 
                                                   xxs[0], xxs[1], xxs[2], 
                                                   phi, mask_corners, 
                                                   admix_props)
    elif phi.ndim == 4:
        if not het_ascertained and not admix_props and not force_direct:
            fs = Spectrum._from_phi_4D_linalg(ns[0], ns[1], ns[2], ns[3],
                                              xxs[0], xxs[1], xxs[2], xxs[3],
                                              phi, mask_corners)
        elif not admix_props:
            fs = Spectrum._from_phi_4D_direct(ns[0], ns[1], ns[2], ns[3],
                                              xxs[0], xxs[1], xxs[2], xxs[3],
                                              phi, mask_corners, 
                                              het_ascertained)
        else:
            fs = Spectrum._from_phi_4D_admix_props(ns[0], ns[1], ns[2], ns[3],
                                                   xxs[0], xxs[1], xxs[2], xxs[3],
                                                   phi, mask_corners, 
                                                   admix_props)
    elif phi.ndim == 5:
        if not het_ascertained and not admix_props and not force_direct:
            fs = Spectrum._from_phi_5D_linalg(ns[0], ns[1], ns[2], ns[3], ns[4],
                                              xxs[0], xxs[1], xxs[2], xxs[3], xxs[4],
                                              phi, mask_corners)
    else:
        raise ValueError(&#39;Only implemented for dimensions 1-5.&#39;)
    fs.pop_ids = pop_ids
    # Record value to use for extrapolation. This is the first grid point,
    # which is where new mutations are introduced. Note that extrapolation
    # will likely fail if grids differ between dimensions.
    fs.extrap_x = xxs[0][1]
    for xx in xxs[1:]:
        if not xx[1] == fs.extrap_x:
            logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                        &#39;different dimensions. Extrapolation may fail.&#39;)
    return fs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_phi_inbreeding"><code class="name flex">
<span>def <span class="ident">from_phi_inbreeding</span></span>(<span>phi, ns, xxs, Fs, ploidys, mask_corners=True, pop_ids=None, admix_props=None, het_ascertained=None, force_direct=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute sample Spectrum from population frequency distribution phi
plus inbreeding.</p>
<p>phi: P-dimensional population frequency distribution.
ns: Sequence of P sample sizes for each population.
xxs: Sequence of P one-dimesional grids on which phi is defined.
Fs: Sequence of P inbreeding coefficients for each population.
ploidys: Sequence of P ploidy levels for each population.
mask_corners: If True, resulting FS is masked in 'absent' and 'fixed'
entries.
pop_ids: Optional list of strings containing the population labels.
If pop_ids is None, labels will be "pop0", "pop1", &hellip;
admix_props: Admixture proportions for sampled individuals. For example,
if there are two populations, and individuals from the
first pop are admixed with fraction f from the second
population, then admix_props=((1-f,f),(0,1)). For three
populations, the no-admixture setting is
admix_props=((1,0,0),(0,1,0),(0,0,1)).
(Note that this option also forces direct integration,
which may be less accurate than the semi-analytic
method.)
het_ascertained: If 'xx', then FS is calculated assuming that SNPs have
been ascertained by being heterozygous in one
individual from population 1. (This individual is
<em>not</em> in the current sample.) If 'yy' or 'zz', it
assumed that the ascertainment individual came from
population 2 or 3, respectively.
(Note that this option also forces direct integration,
which may be less accurate than the semi-analytic
method. This could be fixed if there is interest. Note
also that this option cannot be used simultaneously
with admix_props.)
force_direct: Forces integration to use older direct integration method,
rather than using analytic integration of sampling
formula.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_phi_inbreeding(phi, ns, xxs, Fs, ploidys, mask_corners=True, 
                        pop_ids=None, admix_props=None,
                        het_ascertained=None, force_direct=True):
    &#34;&#34;&#34;
    Compute sample Spectrum from population frequency distribution phi
    plus inbreeding.
    
    phi: P-dimensional population frequency distribution.
    ns: Sequence of P sample sizes for each population.
    xxs: Sequence of P one-dimesional grids on which phi is defined.
    Fs: Sequence of P inbreeding coefficients for each population.
    ploidys: Sequence of P ploidy levels for each population.
    mask_corners: If True, resulting FS is masked in &#39;absent&#39; and &#39;fixed&#39;
                  entries.
    pop_ids: Optional list of strings containing the population labels.
             If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
    admix_props: Admixture proportions for sampled individuals. For example,
                 if there are two populations, and individuals from the
                 first pop are admixed with fraction f from the second
                 population, then admix_props=((1-f,f),(0,1)). For three
                 populations, the no-admixture setting is
                 admix_props=((1,0,0),(0,1,0),(0,0,1)). 
                 (Note that this option also forces direct integration,
                 which may be less accurate than the semi-analytic
                 method.)
    het_ascertained: If &#39;xx&#39;, then FS is calculated assuming that SNPs have
                     been ascertained by being heterozygous in one
                     individual from population 1. (This individual is
                     *not* in the current sample.) If &#39;yy&#39; or &#39;zz&#39;, it
                     assumed that the ascertainment individual came from
                     population 2 or 3, respectively.
                     (Note that this option also forces direct integration,
                     which may be less accurate than the semi-analytic
                     method. This could be fixed if there is interest. Note
                     also that this option cannot be used simultaneously
                     with admix_props.)
    force_direct: Forces integration to use older direct integration method,
                  rather than using analytic integration of sampling 
                  formula.
    &#34;&#34;&#34;
    if admix_props and not numpy.allclose(numpy.sum(admix_props, axis=1),1):
        raise ValueError(&#39;Admixture proportions {0} must sum to 1 for all &#39;
                         &#39;populations.&#39; .format(str(admix_props)))
    if not phi.ndim == len(ns) == len(xxs) == len(Fs) == len(ploidys):
        raise ValueError(&#39;Dimensionality of phi and lengths of ns, xxs, ploidys, and Fs &#39;
                         &#39;do not all agree.&#39;)
    if het_ascertained and not het_ascertained in [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;]:
        raise ValueError(&#34;If used, het_ascertained must be &#39;xx&#39;, &#39;yy&#39;, or &#34;
                         &#34;&#39;zz&#39;.&#34;)

    if admix_props and het_ascertained:
        error = &#34;&#34;&#34;admix_props and het_ascertained options cannot be used 
        simultaneously. Instead, please use the PhiManip methods to 
        implement admixture. If this proves inappropriate for your use, 
        contact the the dadi developers, as it may be possible to support
        both options simultaneously in the future.&#34;&#34;&#34;
        raise NotImplementedError(error)

    if phi.ndim == 1:
        fs = Spectrum._from_phi_1D_direct_inbreeding(ns[0], xxs[0], phi, Fs[0],
                                                     mask_corners, ploidys[0],
                                                     het_ascertained)
    elif phi.ndim == 2:
        fs = Spectrum._from_phi_2D_direct_inbreeding(ns[0], ns[1], xxs[0], xxs[1],
                                                     phi, Fs[0], Fs[1], mask_corners,
                                                     ploidys[0], ploidys[1],
                                                     het_ascertained)
    elif phi.ndim == 3:
        fs = Spectrum._from_phi_3D_direct_inbreeding(ns[0], ns[1], ns[2], 
                                                     xxs[0], xxs[1], xxs[2], 
                                                     phi, Fs[0], Fs[1], Fs[2],
                                                     mask_corners, ploidys[0],
                                                     ploidys[1], ploidys[2],
                                                     het_ascertained)
    else:
        raise ValueError(&#39;Only implemented for dimensions 1,2 or 3.&#39;)
    fs.pop_ids = pop_ids
    # Record value to use for extrapolation. This is the first grid point,
    # which is where new mutations are introduced. Note that extrapolation
    # will likely fail if grids differ between dimensions.
    fs.extrap_x = xxs[0][1]
    for xx in xxs[1:]:
        if not xx[1] == fs.extrap_x:
            logger.warn(&#39;Spectrum calculated from phi different grids for &#39;
                        &#39;different dimensions. Extrapolation may fail.&#39;)
    return fs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.from_sfscode_file"><code class="name flex">
<span>def <span class="ident">from_sfscode_file</span></span>(<span>fid, sites='all', average=True, mask_corners=True, return_header=False, pop_ids=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read frequency spectrum from file of sfs_code output.</p>
<p>fid: string with file name to read from or an open file object.
sites: If sites=='all', return the fs of all sites. If sites == 'syn',
use only synonymous mutations. If sites == 'nonsyn', use
only non-synonymous mutations.
average: If True, the returned fs is the average over the runs in the
file. If False, the returned fs is the sum.
mask_corners: If True, mask the 'absent in all samples' and 'fixed in
all samples' entries.
return_header: If true, the return value is (fs, (command,seeds), where
command and seeds are strings containing the ms
commandline and the seeds used.
pop_ids: Optional list of strings containing the population labels.
If pop_ids is None, labels will be "pop0", "pop1", &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_sfscode_file(fid, sites=&#39;all&#39;, average=True, mask_corners=True, 
                      return_header=False, pop_ids=None):
    &#34;&#34;&#34;
    Read frequency spectrum from file of sfs_code output.

    fid: string with file name to read from or an open file object.
    sites: If sites==&#39;all&#39;, return the fs of all sites. If sites == &#39;syn&#39;,
           use only synonymous mutations. If sites == &#39;nonsyn&#39;, use
           only non-synonymous mutations.
    average: If True, the returned fs is the average over the runs in the 
             file. If False, the returned fs is the sum.
    mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                  all samples&#39; entries.
    return_header: If true, the return value is (fs, (command,seeds), where
                   command and seeds are strings containing the ms
                   commandline and the seeds used.
    pop_ids: Optional list of strings containing the population labels.
             If pop_ids is None, labels will be &#34;pop0&#34;, &#34;pop1&#34;, ...
    &#34;&#34;&#34;
    newfile = False
    # Try to read from fid. If we can&#39;t, assume it&#39;s something that we can
    # use to open a file.
    if not hasattr(fid, &#39;read&#39;):
        newfile = True
        fid = open(fid, &#39;r&#39;)

    if sites == &#39;all&#39;:
        only_nonsyn, only_syn = False, False
    elif sites == &#39;syn&#39;:
        only_nonsyn, only_syn = False, True
    elif sites == &#39;nonsyn&#39;:
        only_nonsyn, only_syn = True, False
    else:
        raise ValueError(&#34;&#39;sites&#39; argument must be one of (&#39;all&#39;, &#39;syn&#39;, &#34;
                         &#34;&#39;nonsyn&#39;).&#34;)
    
    command = fid.readline()
    command_terms = command.split()
    
    runs = int(command_terms[2])
    num_pops = int(command_terms[1])
    
    # sfs_code default is 6 individuals, and I assume diploid pop
    pop_samples = [12] *  num_pops
    if &#39;--sampSize&#39; in command_terms or &#39;-n&#39; in command_terms:
        try:
            pop_flag = command_terms.index(&#39;--sampSize&#39;)
            pop_flag = command_terms.index(&#39;-n&#39;)
        except ValueError:
            pass
        pop_samples = [2*int(command_terms[pop_flag+ii])
                       for ii in range(1, 1+num_pops)]
    
    pop_samples = numpy.asarray(pop_samples)
    pop_fixed_str = [&#39;,%s.-1&#39; % i for i in range(num_pops)]
    pop_count_str = [&#39;,%s.&#39; % i for i in range(num_pops)]
    
    seeds = fid.readline()
    line = fid.readline()
    
    data = numpy.zeros(numpy.asarray(pop_samples)+1, numpy.int_)
    
    # line = //iteration...
    line = fid.readline()
    for iter_ii in range(runs):
        for ii in range(5):
            line = fid.readline()
    
        # It is possible for a mutation to be listed several times in the
        # output.  To accomodate this, I keep a dictionary of identities
        # for those mutations, and hold off processing them until I&#39;ve seen
        # all mutations listed for the iteration.
        mut_dict = {}
        
        # Loop until this iteration ends.
        while not line.startswith(&#39;//&#39;) and line != &#39;&#39;:
            split_line = line.split(&#39;;&#39;)
            if split_line[-1] == &#39;\n&#39;:
                split_line = split_line[:-1]
    
            # Loop over mutations on this line.
            for mut_ii, mutation in enumerate(split_line):
                counts_this_mut = numpy.zeros(num_pops, numpy.int_)
    
                split_mut = mutation.split(&#39;,&#39;)
    
                # Exclude synonymous mutations
                if only_nonsyn and split_mut[7] == &#39;0&#39;:
                    continue
                # Exclude nonsynonymous mutations
                if only_syn and split_mut[7] == &#39;1&#39;:
                    continue
    
                ind_start = len(&#39;,&#39;.join(split_mut[:12]))
                by_individual = mutation[ind_start:]
    
                mut_id = &#39;,&#39;.join(split_mut[:4] + split_mut[5:11])
    
                # Count mutations in each population
                for pop_ii,fixed_str,count_str\
                        in zip(range(num_pops), pop_fixed_str, 
                               pop_count_str):
                    if fixed_str in by_individual:
                        counts_this_mut[pop_ii] = pop_samples[pop_ii]
                    else:
                        counts_this_mut[pop_ii] =\
                                by_individual.count(count_str)
    
                # Initialize the list that will track the counts for this
                # mutation. Using setdefault means that it won&#39;t overwrite
                # if there&#39;s already a list stored there.
                mut_dict.setdefault(mut_id, [0]*num_pops)
                for ii in range(num_pops):
                    if counts_this_mut[ii] &gt; 0 and mut_dict[mut_id][ii] &gt; 0:
                        sys.stderr.write(&#39;Contradicting counts between &#39;
                                         &#39;listings for mutation %s in &#39;
                                         &#39;population %i.&#39; 
                                         % (mut_id, ii))
                    mut_dict[mut_id][ii] = max(counts_this_mut[ii], 
                                               mut_dict[mut_id][ii])
    
            line = fid.readline()
    
        # Now apply all the mutations with fixations that we deffered.
        for mut_id, counts in mut_dict.items():
            if numpy.any(numpy.asarray(counts) &gt; pop_samples):
                sys.stderr.write(&#39;counts_this_mut &gt; pop_samples: %s &gt; &#39;
                                 &#39;%s\n%s\n&#39; % (counts, pop_samples, mut_id))
                counts = numpy.minimum(counts, pop_samples)
            data[tuple(counts)] += 1
    
    if newfile:
        fid.close()
    
    fs = Spectrum(data, mask_corners=mask_corners, pop_ids=pop_ids)
    if average:
        fs /= runs

    if not return_header:
        return fs
    else:
        return fs, (command,seeds)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.fromfile"><code class="name flex">
<span>def <span class="ident">fromfile</span></span>(<span>fname, mask_corners=True, return_comments=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read frequency spectrum from file.</p>
<p>fname: String with file name to read from. If it ends in .gz, gzip
compression is assumed.
mask_corners: If True, mask the 'absent in all samples' and 'fixed in
all samples' entries.
return_comments: If true, the return value is (fs, comments), where
comments is a list of strings containing the comments
from the file (without #'s).</p>
<p>See to_file method for details on the file format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_file(fname, mask_corners=True, return_comments=False):
    &#34;&#34;&#34;
    Read frequency spectrum from file.

    fname: String with file name to read from. If it ends in .gz, gzip
           compression is assumed.
    mask_corners: If True, mask the &#39;absent in all samples&#39; and &#39;fixed in
                  all samples&#39; entries.
    return_comments: If true, the return value is (fs, comments), where
                     comments is a list of strings containing the comments
                     from the file (without #&#39;s).

    See to_file method for details on the file format.
    &#34;&#34;&#34;
    if fname.endswith(&#39;.gz&#39;):
        fid = gzip.open(fname, &#39;rb&#39;)
    else:
        fid = open(fname, &#39;r&#39;)

    line = fid.readline()
    # Strip out the comments
    comments = []
    while line.startswith(&#39;#&#39;):
        comments.append(line[1:].strip())
        line = fid.readline()

    # Read the shape of the data
    shape_spl = line.split()
    if &#39;folded&#39; not in shape_spl and &#39;unfolded&#39; not in shape_spl:
        # This case handles the old file format
        shape = tuple([int(d) for d in shape_spl])
        folded = False
        pop_ids = None
    else:
        # This case handles the new file format
        shape,next_ii = [int(shape_spl[0])], 1
        while shape_spl[next_ii] not in [&#39;folded&#39;, &#39;unfolded&#39;]:
            shape.append(int(shape_spl[next_ii]))
            next_ii += 1
        folded = (shape_spl[next_ii] == &#39;folded&#39;)
        # Are there population labels in the file?
        if len(shape_spl) &gt; next_ii + 1:
            pop_ids = line.split(&#39;&#34;&#39;)[1::2]
        else:
            pop_ids = None

    data = numpy.fromstring(fid.readline().strip(), 
                            count=numpy.product(shape), sep=&#39; &#39;)
    # fromfile returns a 1-d array. Reshape it to the proper form.
    data = data.reshape(*shape)

    maskline = fid.readline().strip()
    if not maskline:
        # The old file format didn&#39;t have a line for the mask
        mask = None
    else:
        # This case handles the new file format
        mask = numpy.fromstring(maskline, 
                                count=numpy.product(shape), sep=&#39; &#39;)
        mask = mask.reshape(*shape)

    fs = Spectrum(data, mask, mask_corners, data_folded=folded,
                  pop_ids=pop_ids)

    fid.close()
    if not return_comments:
        return fs
    else:
        return fs,comments</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum.Npop"><code class="name">var <span class="ident">Npop</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _get_Npop(self):
    return self.ndim</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.sample_sizes"><code class="name">var <span class="ident">sample_sizes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _get_sample_sizes(self):
    return numpy.asarray(self.shape) - 1</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dadi.Spectrum_mod.Spectrum.Fst"><code class="name flex">
<span>def <span class="ident">Fst</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wright's Fst between the populations represented in the fs.</p>
<p>This estimate of Fst assumes random mating, because we don't have
heterozygote frequencies in the fs.</p>
<p>Calculation is by the method of Weir and Cockerham <em>Evolution</em> 38:1358
(1984).
For a single SNP, the relevant formula is at the top of page
1363. To combine results between SNPs, we use the weighted average
indicated by equation 10.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Fst(self):
    &#34;&#34;&#34;
    Wright&#39;s Fst between the populations represented in the fs.

    This estimate of Fst assumes random mating, because we don&#39;t have
    heterozygote frequencies in the fs.

    Calculation is by the method of Weir and Cockerham _Evolution_ 38:1358
    (1984).  For a single SNP, the relevant formula is at the top of page
    1363. To combine results between SNPs, we use the weighted average
    indicated by equation 10.
    &#34;&#34;&#34;
    # This gets a little obscure because we want to be able to work with
    # spectra of arbitrary dimension.

    # First quantities from page 1360
    r = self.Npop
    ns = self.sample_sizes
    nbar = numpy.mean(ns)
    nsum = numpy.sum(ns)
    nc = (nsum - numpy.sum(ns**2)/nsum)/(r-1)

    # counts_per_pop is an r+1 dimensional array, where the last axis simply
    # records the indices of the entry. 
    # For example, counts_per_pop[4,19,8] = [4,19,8]
    counts_per_pop = numpy.indices(self.shape)
    counts_per_pop = numpy.transpose(counts_per_pop, axes=list(range(1,r+1))+[0])

    # The last axis of ptwiddle is now the relative frequency of SNPs in
    # that bin in each of the populations.
    ptwiddle = 1.*counts_per_pop/ns

    # Note that pbar is of the same shape as fs...
    pbar = numpy.sum(ns*ptwiddle, axis=-1)/nsum

    # We need to use &#39;this_slice&#39; to get the proper aligment between
    # ptwiddle and pbar.
    this_slice = [slice(None)]*r + [numpy.newaxis]
    s2 = numpy.sum(ns * (ptwiddle - pbar[tuple(this_slice)])**2, axis=-1)/((r-1)*nbar)

    # Note that this &#39;a&#39; differs from equation 2, because we&#39;ve used
    # equation 3 and b = 0 to solve for hbar.
    a = nbar/nc * (s2 - 1/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2))
    d = 2*nbar/(2*nbar-1) * (pbar*(1-pbar) - (r-1)/r*s2)

    # The weighted sum over loci.
    asum = (self * a).sum()
    dsum = (self * d).sum()

    return asum/(asum+dsum)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.S"><code class="name flex">
<span>def <span class="ident">S</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Segregating sites.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def S(self):
    &#34;&#34;&#34;
    Segregating sites.
    &#34;&#34;&#34;
    oldmask = self.mask.copy()
    self.mask_corners()
    S = self.sum()
    self.mask = oldmask
    return S</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.Tajima_D"><code class="name flex">
<span>def <span class="ident">Tajima_D</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tajima's D.</p>
<p>Following Gillespie "Population Genetics: A Concise Guide" pg. 45</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Tajima_D(self):
    &#34;&#34;&#34;
    Tajima&#39;s D.

    Following Gillespie &#34;Population Genetics: A Concise Guide&#34; pg. 45
    &#34;&#34;&#34;
    if not self.Npop == 1:
        raise ValueError(&#34;Only defined on a one-dimensional SFS.&#34;)

    S = self.S()

    n = 1.*self.sample_sizes[0]
    pihat = self.pi()
    theta = self.Watterson_theta()

    a1 = numpy.sum(1./numpy.arange(1,n))
    a2 = numpy.sum(1./numpy.arange(1,n)**2)
    b1 = (n+1)/(3*(n-1))
    b2 = 2*(n**2 + n + 3)/(9*n * (n-1))
    c1 = b1 - 1./a1
    c2 = b2 - (n+2)/(a1*n) + a2/a1**2

    C = numpy.sqrt((c1/a1)*S + c2/(a1**2 + a2) * S*(S-1))

    return (pihat - theta)/C</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.Watterson_theta"><code class="name flex">
<span>def <span class="ident">Watterson_theta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Watterson's estimator of theta.</p>
<p>Note that is only sensible for 1-dimensional spectra.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Watterson_theta(self):
    &#34;&#34;&#34;
    Watterson&#39;s estimator of theta.

    Note that is only sensible for 1-dimensional spectra.
    &#34;&#34;&#34;
    if self.Npop != 1:
        raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)

    n = self.sample_sizes[0]
    S = self.S()
    an = numpy.sum(1./numpy.arange(1,n))

    return S/an</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.Zengs_E"><code class="name flex">
<span>def <span class="ident">Zengs_E</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Zeng et al.'s E statistic.</p>
<p>From Zeng et al. "Statistical Tests for Detecting Positive Selection by
Utilizing High-Frequency Variants" (2006) Genetics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Zengs_E(self):
    &#34;&#34;&#34;
    Zeng et al.&#39;s E statistic.

    From Zeng et al. &#34;Statistical Tests for Detecting Positive Selection by
    Utilizing High-Frequency Variants&#34; (2006) Genetics
    &#34;&#34;&#34;
    num = self.theta_L() - self.Watterson_theta()

    n = self.sample_sizes[0]

    # See after Eq. 3
    an = numpy.sum(1./numpy.arange(1,n))
    # See after Eq. 9
    bn = numpy.sum(1./numpy.arange(1,n)**2)
    s = self.S()

    # See immediately after Eq. 12
    theta = self.Watterson_theta()
    theta_sq = s*(s-1.)/(an**2 + bn)

    # Eq. 14
    var = (n/(2.*(n-1.)) - 1./an) * theta\
            + (bn/an**2 + 2.*(n/(n-1.))**2 * bn - 2*(n*bn-n+1.)/((n-1.)*an)
               - (3.*n+1.)/(n-1.)) * theta_sq

    return num/numpy.sqrt(var)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.filter_pops"><code class="name flex">
<span>def <span class="ident">filter_pops</span></span>(<span>self, tokeep, mask_corners=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter Spectrum to keep only certain populations.</p>
<p>Returns new Spectrum with len(tokeep) populations.
Note: This is similar in practice to the marginalize operation. But here
populations are numbered from 1, as in the majority of dadi.</p>
<p>tokeep: List of population numbers to keep, numbering from 1.
mask_corners: If True, the typical corners of the resulting fs will be
masked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_pops(self, tokeep, mask_corners=True):
    &#34;&#34;&#34;
    Filter Spectrum to keep only certain populations.

    Returns new Spectrum with len(tokeep) populations.
    Note: This is similar in practice to the marginalize operation. But here
          populations are numbered from 1, as in the majority of dadi.

    tokeep: List of population numbers to keep, numbering from 1.
    mask_corners: If True, the typical corners of the resulting fs will be
                  masked
    &#34;&#34;&#34;
    toremove = list(range(0, self.ndim))
    for pop_ii in tokeep:
        # Apply -1 factor to account for indexing in marginalize
        toremove.remove(pop_ii-1)
    return self.marginalize(toremove)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.fixed_size_sample"><code class="name flex">
<span>def <span class="ident">fixed_size_sample</span></span>(<span>self, nsamples, only_nonmasked=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a resampled fs from the current one.</p>
<p>nsamples: Number of samples to include in the new FS.
only_nonmasked: If True, only SNPs from non-masked will be resampled.
Otherwise, all SNPs will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_size_sample(self, nsamples, only_nonmasked=False):
    &#34;&#34;&#34;
    Generate a resampled fs from the current one.

    nsamples: Number of samples to include in the new FS.
    only_nonmasked: If True, only SNPs from non-masked will be resampled. 
                    Otherwise, all SNPs will be used.
    &#34;&#34;&#34;
    flat = self.flatten()
    if only_nonmasked:
        pvals = flat.data/flat.sum()
        pvals[flat.mask] = 0
    else:
        pvals = flat.data/flat.data.sum()

    sample = numpy.random.multinomial(int(nsamples), pvals)
    sample = sample.reshape(self.shape)

    return dadi.Spectrum(sample, mask=self.mask, pop_ids=self.pop_ids)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Folded frequency spectrum</p>
<p>The folded fs assumes that information on which allele is ancestral or
derived is unavailable. Thus the fs is in terms of minor allele
frequency.
Note that this makes the fs into a "triangular" array.</p>
<p>Note that if a masked cell is folded into non-masked cell, the
destination cell is masked as well.</p>
<p>Note also that folding is not done in-place. The return value is a new
Spectrum object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self):
    &#34;&#34;&#34;
    Folded frequency spectrum

    The folded fs assumes that information on which allele is ancestral or
    derived is unavailable. Thus the fs is in terms of minor allele 
    frequency.  Note that this makes the fs into a &#34;triangular&#34; array.

    Note that if a masked cell is folded into non-masked cell, the
    destination cell is masked as well.

    Note also that folding is not done in-place. The return value is a new
    Spectrum object.
    &#34;&#34;&#34;
    if self.folded:
        raise ValueError(&#39;Input Spectrum is already folded.&#39;)

    # How many samples total do we have? The folded fs can only contain
    # entries up to total_samples/2 (rounded down).
    total_samples = numpy.sum(self.sample_sizes)

    total_per_entry = self._total_per_entry()

    # Here&#39;s where we calculate which entries are nonsense in the folded fs.
    where_folded_out = total_per_entry &gt; int(total_samples/2)

    original_mask = self.mask
    # Here we create a mask that masks any values that were masked in
    # the original fs (or folded onto by a masked value).
    final_mask = numpy.logical_or(original_mask, 
                                  reverse_array(original_mask))
    
    # To do the actual folding, we take those entries that would be folded
    # out, reverse the array along all axes, and add them back to the
    # original fs.
    reversed = reverse_array(numpy.where(where_folded_out, self, 0))
    folded = numpy.ma.masked_array(self.data + reversed)
    folded.data[where_folded_out] = 0

    # Deal with those entries where assignment of the minor allele is
    # ambiguous.
    where_ambiguous = (total_per_entry == total_samples/2.)
    ambiguous = numpy.where(where_ambiguous, self, 0)
    folded += -0.5*ambiguous + 0.5*reverse_array(ambiguous)

    # Mask out the remains of the folding operation.
    final_mask = numpy.logical_or(final_mask, where_folded_out)

    outfs = Spectrum(folded, mask=final_mask, data_folded=True,
                     pop_ids=self.pop_ids)
    outfs.extrap_x = self.extrap_x
    return outfs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the natural logarithm of the entries of the frequency spectrum.</p>
<p>Only necessary because numpy.ma.log now fails to propagate extra
attributes after numpy 1.10.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self):
    &#34;&#34;&#34;
    Return the natural logarithm of the entries of the frequency spectrum.

    Only necessary because numpy.ma.log now fails to propagate extra
    attributes after numpy 1.10.
    &#34;&#34;&#34;
    logfs = numpy.ma.log(self)
    logfs.folded = self.folded
    logfs.pop_ids = self.pop_ids
    logfs.extrap_x = self.extrap_x
    return logfs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.marginalize"><code class="name flex">
<span>def <span class="ident">marginalize</span></span>(<span>self, over, mask_corners=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduced dimensionality spectrum summing over some populations.</p>
<p>over: sequence of axes to sum over. For example (0,2) will sum over
populations 0 and 2.
mask_corners: If True, the typical corners of the resulting fs will be
masked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marginalize(self, over, mask_corners=True):
    &#34;&#34;&#34;
    Reduced dimensionality spectrum summing over some populations.

    over: sequence of axes to sum over. For example (0,2) will sum over
          populations 0 and 2.
    mask_corners: If True, the typical corners of the resulting fs will be
                  masked
    &#34;&#34;&#34;
    original_folded = self.folded
    # If we started with an folded Spectrum, we need to unfold before
    # marginalizing.
    if original_folded:
        output = self.unfold()
    else:
        output = self.copy()

    orig_mask = output.mask.copy()
    orig_mask.flat[0] = orig_mask.flat[-1] = False
    if numpy.any(orig_mask):
        logger.warn(&#39;Marginalizing a Spectrum with internal masked values. &#39;
                    &#39;This may not be a well-defined operation.&#39;)

    # Do the marginalization
    for axis in sorted(over)[::-1]:
        output = output.sum(axis=axis)
    pop_ids = None
    if self.pop_ids is not None:
        pop_ids = list(self.pop_ids)
        for axis in sorted(over)[::-1]:
            del pop_ids[axis]
    output.folded = False
    output.pop_ids = pop_ids
    output.extrap_x = self.extrap_x

    if mask_corners:
        output.mask_corners()

    # Return folded or unfolded as original.
    if original_folded:
        return output.fold()
    else:
        return output</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.mask_corners"><code class="name flex">
<span>def <span class="ident">mask_corners</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mask the 'seen in 0 samples' and 'seen in all samples' entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_corners(self):
    &#34;&#34;&#34;
    Mask the &#39;seen in 0 samples&#39; and &#39;seen in all samples&#39; entries.
    &#34;&#34;&#34;
    self.mask.flat[0] = self.mask.flat[-1] = True</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.pi"><code class="name flex">
<span>def <span class="ident">pi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimated expected number of pairwise differences between two
chromosomes in the population.</p>
<p>Note that this estimate includes a factor of sample_size/(sample_size-1)
to make E(\hat{pi}) = theta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi(self):
    r&#34;&#34;&#34;
    Estimated expected number of pairwise differences between two
    chromosomes in the population.

    Note that this estimate includes a factor of sample_size/(sample_size-1)
    to make E(\hat{pi}) = theta.
    &#34;&#34;&#34;
    if self.ndim != 1:
        raise ValueError(&#34;Only defined for a one-dimensional SFS.&#34;)

    n = self.sample_sizes[0]
    # sample frequencies p 
    p = numpy.arange(0,n+1,dtype=float)/n
    # This expression derives from Gillespie&#39;s _Population_Genetics:_A
    # _Concise_Guide_, 2nd edition, section 2.6.
    return n/(n-1.) * 2*numpy.ma.sum(self*p*(1-p))</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, ns)</span>
</code></dt>
<dd>
<div class="desc"><p>Project to smaller sample size.</p>
<p>ns: Sample sizes for new spectrum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, ns):
    &#34;&#34;&#34;
    Project to smaller sample size.

    ns: Sample sizes for new spectrum.
    &#34;&#34;&#34;
    if len(ns) != self.Npop:
        raise ValueError(&#39;Requested sample sizes not of same dimension &#39;
                         &#39;as spectrum. Perhaps you need to marginalize &#39;
                         &#39;over some populations first?&#39;)
    if numpy.any(numpy.asarray(ns) &gt; numpy.asarray(self.sample_sizes)):
        raise ValueError(&#39;Cannot project to a sample size greater than &#39;
                         &#39;original. Original size is %s and requested size &#39;
                         &#39;is %s.&#39; % (self.sample_sizes, ns))

    original_folded = self.folded
    # If we started with an folded Spectrum, we need to unfold before
    # projecting.
    if original_folded:
        output = self.unfold()
    else:
        output = self.copy()

    # Iterate over each axis, applying the projection.
    for axis,proj in enumerate(ns):
        if proj != self.sample_sizes[axis]:
            output = output._project_one_axis(proj, axis)

    output.pop_ids = self.pop_ids
    output.extrap_x = self.extrap_x

    # Return folded or unfolded as original.
    if original_folded:
        return output.fold()
    else:
        return output</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Poisson-sampled fs from the current one.</p>
<p>Note: Entries where the current fs is masked will be masked in the
output sampled fs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self):
    &#34;&#34;&#34;
    Generate a Poisson-sampled fs from the current one.

    Note: Entries where the current fs is masked will be masked in the
          output sampled fs.
    &#34;&#34;&#34;
    import scipy.stats
    # These are entries where the sampling has no meaning, b/c fs is masked.
    bad_entries = self.mask
    # We convert to a 1-d array for passing into the sampler
    means = self.ravel().copy()
    # Filter out those bad entries.
    means[bad_entries.ravel()] = 1
    # Sample
    samp = scipy.stats.distributions.poisson.rvs(means, size=len(means))
    # Replace bad entries with zero
    samp[bad_entries.ravel()] = 0
    # Convert back to a properly shaped array
    samp = samp.reshape(self.shape)
    # Convert to a fs and mask the bad entries
    samp = Spectrum(samp, mask=self.mask, data_folded=self.folded,
                    pop_ids = self.pop_ids)
    return samp</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.scramble_pop_ids"><code class="name flex">
<span>def <span class="ident">scramble_pop_ids</span></span>(<span>self, mask_corners=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Spectrum corresponding to scrambling individuals among populations.</p>
<p>This is useful for assessing how diverged populations are.
Essentially, it pools all the individuals represented in the fs and
generates new populations of random individuals (without replacement)
from that pool. If this fs is significantly different from the
original, that implies population structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scramble_pop_ids(self, mask_corners=True):
    &#34;&#34;&#34;
    Spectrum corresponding to scrambling individuals among populations.
    
    This is useful for assessing how diverged populations are.
    Essentially, it pools all the individuals represented in the fs and
    generates new populations of random individuals (without replacement)
    from that pool. If this fs is significantly different from the
    original, that implies population structure.
    &#34;&#34;&#34;
    original_folded = self.folded
    # If we started with an folded Spectrum, we need to unfold before
    # projecting.
    if original_folded:
        self = self.unfold()

    total_samp = numpy.sum(self.sample_sizes)

    # First generate a 1d sfs for the pooled population.
    combined = numpy.zeros(total_samp+1)
    # For each entry in the fs, this is the total number of derived alleles
    total_per_entry = self._total_per_entry()
    # Sum up to generate the equivalent 1-d spectrum.
    for derived,counts in zip(total_per_entry.ravel(), self.ravel()):
        combined[derived] += counts

    # Now resample back into a n-d spectrum
    # For each entry, this is the counts per popuation. 
    #  e.g. counts_per_entry[3,4,5] = [3,4,5]
    counts_per_entry = self._counts_per_entry()
    # Reshape it to be 1-d, so we can iterate over it easily.
    counts_per_entry = counts_per_entry.reshape(numpy.prod(self.shape), 
                                                self.ndim)
    resamp = numpy.zeros(self.shape)
    for counts, derived in zip(counts_per_entry, total_per_entry.ravel()):
        # The probability here is 
        # (t1 choose d1)*(t2 choose d2)/(ntot choose derived)
        lnprob = sum(_lncomb(t,d) for t,d in zip(self.sample_sizes,counts))
        lnprob -= _lncomb(total_samp, derived)
        prob = numpy.exp(lnprob)
        # Assign result using the appropriate weighting
        resamp[tuple(counts)] += prob*combined[derived]

    resamp = Spectrum(resamp, mask_corners=mask_corners)
    if not original_folded:
        return resamp
    else:
        return resamp.fold()</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.theta_L"><code class="name flex">
<span>def <span class="ident">theta_L</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>theta_L as defined by Zeng et al. "Statistical Tests for Detecting
Positive Selection by Utilizing High-Frequency Variants" (2006)
Genetics</p>
<p>Note that is only sensible for 1-dimensional spectra.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def theta_L(self):
    &#34;&#34;&#34;
    theta_L as defined by Zeng et al. &#34;Statistical Tests for Detecting
    Positive Selection by Utilizing High-Frequency Variants&#34; (2006)
    Genetics

    Note that is only sensible for 1-dimensional spectra.
    &#34;&#34;&#34;
    if self.Npop != 1:
        raise ValueError(&#34;Only defined on a one-dimensional fs.&#34;)

    n = self.sample_sizes[0]
    return numpy.sum(numpy.arange(1,n)*self[1:n])/(n-1)</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, fname, precision=16, comment_lines=[], foldmaskinfo=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Write frequency spectrum to file.</p>
<p>fname: File name to write to.
If string ends in .gz, file will be saved
with gzip compression.
precision: precision with which to write out entries of the SFS. (They
are formated via %.<p>g, where <p> is the precision.)
comment lines: list of strings to be used as comment lines in the header
of the output file.
foldmaskinfo: If False, folding and mask and population label
information will not be saved. This conforms to the file
format for dadi versions prior to 1.3.0.</p>
<p>The file format is:
# Any number of comment lines beginning with a '#'
A single line containing N integers giving the dimensions of the fs
array. So this line would be '5 5 3' for an SFS that was 5x5x3.
(That would be 4x4x2 <em>samples</em>.)
On the <em>same line</em>, the string 'folded' or 'unfolded' denoting the
folding status of the array
On the <em>same line</em>, optional strings each containing the population
labels in quotes separated by spaces, e.g. "pop 1" "pop 2"
A single line giving the array elements. The order of elements is
e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] &hellip; fs[0,1,0] fs[0,1,1] &hellip;
A single line giving the elements of the mask in the same order as
the data line. '1' indicates masked, '0' indicates unmasked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, fname, precision=16, comment_lines = [], 
            foldmaskinfo=True):
    &#34;&#34;&#34;
    Write frequency spectrum to file.

    fname: File name to write to.  If string ends in .gz, file will be saved
           with gzip compression.
    precision: precision with which to write out entries of the SFS. (They
               are formated via %.&lt;p&gt;g, where &lt;p&gt; is the precision.)
    comment lines: list of strings to be used as comment lines in the header
                   of the output file.
    foldmaskinfo: If False, folding and mask and population label
                  information will not be saved. This conforms to the file
                  format for dadi versions prior to 1.3.0.

    The file format is:
        # Any number of comment lines beginning with a &#39;#&#39;
        A single line containing N integers giving the dimensions of the fs
          array. So this line would be &#39;5 5 3&#39; for an SFS that was 5x5x3.
          (That would be 4x4x2 *samples*.)
        On the *same line*, the string &#39;folded&#39; or &#39;unfolded&#39; denoting the
          folding status of the array
        On the *same line*, optional strings each containing the population
          labels in quotes separated by spaces, e.g. &#34;pop 1&#34; &#34;pop 2&#34;
        A single line giving the array elements. The order of elements is 
          e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] ... fs[0,1,0] fs[0,1,1] ...
        A single line giving the elements of the mask in the same order as
          the data line. &#39;1&#39; indicates masked, &#39;0&#39; indicates unmasked.
    &#34;&#34;&#34;
    # Open the file object.
    if fname.endswith(&#39;.gz&#39;):
        fid = gzip.open(fname, &#39;wb&#39;)
    else:
        fid = open(fname, &#39;w&#39;)

    # Write comments
    for line in comment_lines:
        fid.write(&#39;# &#39;)
        fid.write(line.strip())
        fid.write(&#39;\n&#39;)

    # Write out the shape of the fs
    for elem in self.data.shape:
        fid.write(&#39;%i &#39; % elem)

    if foldmaskinfo:
        if not self.folded:
            fid.write(&#39;unfolded&#39;)
        else:
            fid.write(&#39;folded&#39;)
        if self.pop_ids is not None:
            for label in self.pop_ids:
                fid.write(&#39; &#34;%s&#34;&#39; % label)

    fid.write(&#39;\n&#39;)

    # Write the data to the file. The obnoxious ravel call is to
    # ensure compatibility with old version that used self.data.tofile.
    numpy.savetxt(fid, [self.data.ravel()], delimiter=&#39; &#39;,
                  fmt=&#39;%%.%ig&#39; % precision)

    if foldmaskinfo:
        # Write the mask to the file
        numpy.savetxt(fid, [numpy.asarray(self.mask, int).ravel()],
                      delimiter=&#39; &#39;, fmt=&#39;%d&#39;)

    fid.close()</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.tofile"><code class="name flex">
<span>def <span class="ident">tofile</span></span>(<span>self, fname, precision=16, comment_lines=[], foldmaskinfo=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Write frequency spectrum to file.</p>
<p>fname: File name to write to.
If string ends in .gz, file will be saved
with gzip compression.
precision: precision with which to write out entries of the SFS. (They
are formated via %.<p>g, where <p> is the precision.)
comment lines: list of strings to be used as comment lines in the header
of the output file.
foldmaskinfo: If False, folding and mask and population label
information will not be saved. This conforms to the file
format for dadi versions prior to 1.3.0.</p>
<p>The file format is:
# Any number of comment lines beginning with a '#'
A single line containing N integers giving the dimensions of the fs
array. So this line would be '5 5 3' for an SFS that was 5x5x3.
(That would be 4x4x2 <em>samples</em>.)
On the <em>same line</em>, the string 'folded' or 'unfolded' denoting the
folding status of the array
On the <em>same line</em>, optional strings each containing the population
labels in quotes separated by spaces, e.g. "pop 1" "pop 2"
A single line giving the array elements. The order of elements is
e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] &hellip; fs[0,1,0] fs[0,1,1] &hellip;
A single line giving the elements of the mask in the same order as
the data line. '1' indicates masked, '0' indicates unmasked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(self, fname, precision=16, comment_lines = [], 
            foldmaskinfo=True):
    &#34;&#34;&#34;
    Write frequency spectrum to file.

    fname: File name to write to.  If string ends in .gz, file will be saved
           with gzip compression.
    precision: precision with which to write out entries of the SFS. (They
               are formated via %.&lt;p&gt;g, where &lt;p&gt; is the precision.)
    comment lines: list of strings to be used as comment lines in the header
                   of the output file.
    foldmaskinfo: If False, folding and mask and population label
                  information will not be saved. This conforms to the file
                  format for dadi versions prior to 1.3.0.

    The file format is:
        # Any number of comment lines beginning with a &#39;#&#39;
        A single line containing N integers giving the dimensions of the fs
          array. So this line would be &#39;5 5 3&#39; for an SFS that was 5x5x3.
          (That would be 4x4x2 *samples*.)
        On the *same line*, the string &#39;folded&#39; or &#39;unfolded&#39; denoting the
          folding status of the array
        On the *same line*, optional strings each containing the population
          labels in quotes separated by spaces, e.g. &#34;pop 1&#34; &#34;pop 2&#34;
        A single line giving the array elements. The order of elements is 
          e.g.: fs[0,0,0] fs[0,0,1] fs[0,0,2] ... fs[0,1,0] fs[0,1,1] ...
        A single line giving the elements of the mask in the same order as
          the data line. &#39;1&#39; indicates masked, &#39;0&#39; indicates unmasked.
    &#34;&#34;&#34;
    # Open the file object.
    if fname.endswith(&#39;.gz&#39;):
        fid = gzip.open(fname, &#39;wb&#39;)
    else:
        fid = open(fname, &#39;w&#39;)

    # Write comments
    for line in comment_lines:
        fid.write(&#39;# &#39;)
        fid.write(line.strip())
        fid.write(&#39;\n&#39;)

    # Write out the shape of the fs
    for elem in self.data.shape:
        fid.write(&#39;%i &#39; % elem)

    if foldmaskinfo:
        if not self.folded:
            fid.write(&#39;unfolded&#39;)
        else:
            fid.write(&#39;folded&#39;)
        if self.pop_ids is not None:
            for label in self.pop_ids:
                fid.write(&#39; &#34;%s&#34;&#39; % label)

    fid.write(&#39;\n&#39;)

    # Write the data to the file. The obnoxious ravel call is to
    # ensure compatibility with old version that used self.data.tofile.
    numpy.savetxt(fid, [self.data.ravel()], delimiter=&#39; &#39;,
                  fmt=&#39;%%.%ig&#39; % precision)

    if foldmaskinfo:
        # Write the mask to the file
        numpy.savetxt(fid, [numpy.asarray(self.mask, int).ravel()],
                      delimiter=&#39; &#39;, fmt=&#39;%d&#39;)

    fid.close()</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unfolded frequency spectrum</p>
<p>It is assumed that each state of a SNP is equally likely to be
ancestral.</p>
<p>Note also that unfolding is not done in-place. The return value is a new
Spectrum object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfold(self):
    &#34;&#34;&#34;
    Unfolded frequency spectrum

    It is assumed that each state of a SNP is equally likely to be
    ancestral.

    Note also that unfolding is not done in-place. The return value is a new
    Spectrum object.
    &#34;&#34;&#34;
    if not self.folded:
        raise ValueError(&#39;Input Spectrum is not folded.&#39;)

    # Unfolding the data is easy.
    reversed_data = reverse_array(self.data)
    newdata = (self.data + reversed_data)/2.

    # Unfolding the mask is trickier. We want to preserve masking of entries
    # that were masked in the original Spectrum.
    # Which entries in the original Spectrum were masked solely because
    # they are incompatible with a folded Spectrum?
    total_samples = numpy.sum(self.sample_sizes)
    total_per_entry = self._total_per_entry()
    where_folded_out = total_per_entry &gt; int(total_samples/2)

    newmask = numpy.logical_xor(self.mask, where_folded_out)
    newmask = numpy.logical_or(newmask, reverse_array(newmask))

    outfs = Spectrum(newdata, mask=newmask, data_folded=False, 
                     pop_ids=self.pop_ids)
    outfs.extrap_x = self.extrap_x
    return outfs</code></pre>
</details>
</dd>
<dt id="dadi.Spectrum_mod.Spectrum.unmask_all"><code class="name flex">
<span>def <span class="ident">unmask_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unmask all values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unmask_all(self):
    &#34;&#34;&#34;
    Unmask all values.
    &#34;&#34;&#34;
    self.mask[[slice(None)]*self.Npop] = False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dadi" href="index.html">dadi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dadi.Spectrum_mod.Spectrum_pickler" href="#dadi.Spectrum_mod.Spectrum_pickler">Spectrum_pickler</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum_unpickler" href="#dadi.Spectrum_mod.Spectrum_unpickler">Spectrum_unpickler</a></code></li>
<li><code><a title="dadi.Spectrum_mod.cached_dbeta" href="#dadi.Spectrum_mod.cached_dbeta">cached_dbeta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dadi.Spectrum_mod.Spectrum" href="#dadi.Spectrum_mod.Spectrum">Spectrum</a></code></h4>
<ul class="">
<li><code><a title="dadi.Spectrum_mod.Spectrum.Fst" href="#dadi.Spectrum_mod.Spectrum.Fst">Fst</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.Npop" href="#dadi.Spectrum_mod.Spectrum.Npop">Npop</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.S" href="#dadi.Spectrum_mod.Spectrum.S">S</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.Tajima_D" href="#dadi.Spectrum_mod.Spectrum.Tajima_D">Tajima_D</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.Watterson_theta" href="#dadi.Spectrum_mod.Spectrum.Watterson_theta">Watterson_theta</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.Zengs_E" href="#dadi.Spectrum_mod.Spectrum.Zengs_E">Zengs_E</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.filter_pops" href="#dadi.Spectrum_mod.Spectrum.filter_pops">filter_pops</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.fixed_size_sample" href="#dadi.Spectrum_mod.Spectrum.fixed_size_sample">fixed_size_sample</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.fold" href="#dadi.Spectrum_mod.Spectrum.fold">fold</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_data_dict" href="#dadi.Spectrum_mod.Spectrum.from_data_dict">from_data_dict</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_data_dict_corrected" href="#dadi.Spectrum_mod.Spectrum.from_data_dict_corrected">from_data_dict_corrected</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_file" href="#dadi.Spectrum_mod.Spectrum.from_file">from_file</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_ms_file" href="#dadi.Spectrum_mod.Spectrum.from_ms_file">from_ms_file</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_phi" href="#dadi.Spectrum_mod.Spectrum.from_phi">from_phi</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_phi_inbreeding" href="#dadi.Spectrum_mod.Spectrum.from_phi_inbreeding">from_phi_inbreeding</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.from_sfscode_file" href="#dadi.Spectrum_mod.Spectrum.from_sfscode_file">from_sfscode_file</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.fromfile" href="#dadi.Spectrum_mod.Spectrum.fromfile">fromfile</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.log" href="#dadi.Spectrum_mod.Spectrum.log">log</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.marginalize" href="#dadi.Spectrum_mod.Spectrum.marginalize">marginalize</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.mask_corners" href="#dadi.Spectrum_mod.Spectrum.mask_corners">mask_corners</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.method" href="#dadi.Spectrum_mod.Spectrum.method">method</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.pi" href="#dadi.Spectrum_mod.Spectrum.pi">pi</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.project" href="#dadi.Spectrum_mod.Spectrum.project">project</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.sample" href="#dadi.Spectrum_mod.Spectrum.sample">sample</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.sample_sizes" href="#dadi.Spectrum_mod.Spectrum.sample_sizes">sample_sizes</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.scramble_pop_ids" href="#dadi.Spectrum_mod.Spectrum.scramble_pop_ids">scramble_pop_ids</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.theta_L" href="#dadi.Spectrum_mod.Spectrum.theta_L">theta_L</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.to_file" href="#dadi.Spectrum_mod.Spectrum.to_file">to_file</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.tofile" href="#dadi.Spectrum_mod.Spectrum.tofile">tofile</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.unfold" href="#dadi.Spectrum_mod.Spectrum.unfold">unfold</a></code></li>
<li><code><a title="dadi.Spectrum_mod.Spectrum.unmask_all" href="#dadi.Spectrum_mod.Spectrum.unmask_all">unmask_all</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>